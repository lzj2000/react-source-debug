# Lane 优先级模型与时间切片调度

# 1. 引言：并发渲染与优先级问题

在 React 早期版本中，组件的渲染过程是同步且不可中断的。当应用需要渲染大型组件树或处理频繁更新时，JavaScript 主线程会被长时间占用，导致浏览器无法及时响应用户输入（如点击、滚动），最终表现为页面卡顿、交互延迟 —— 这是传统同步渲染模型的核心痛点。

为解决这一问题，React 引入了并发渲染的理念，其核心目标是让渲染过程变得可中断、可恢复、可调度。而实现这一目标的两大支柱，正是 Lane 优先级模型与时间切片调度：

1. Lane 优先级模型：为不同类型的更新任务（如用户交互、数据加载、动画渲染等）赋予明确的优先级层级，让 React 能够识别 “什么任务更紧急”。
2. 时间切片调度：将原本一次性完成的渲染工作拆分为多个 “时间片段”，每次只占用浏览器一帧（约 16ms）中的部分时间执行，剩余时间交还给浏览器处理用户交互，从而避免主线程阻塞。

# 2. Lane 优先级模型

## 2.1 位掩码优先级的数学原理

React 的 Lane 优先级模型巧妙地利用了位掩码（Bitmask）这一计算机科学中的基础概念来表示和管理更新的优先级。

## 2.1.1 位掩码的基本概念

位掩码是一种使用二进制位（bit）来表示一组布尔值或状态的技术。在位掩码中，每一个独立的位都代表一个特定的标志或属性。如果某个位被设置为 1，则表示对应的标志为真；如果为 0，则表示为假。在 Lanes 模型中，每个位代表一个特定的优先级级别或更新类型：

```js
// 总车道数：React 限制 Lane 总数为 31（基于 31 位二进制设计）
export const TotalLanes = 31;

// 无优先级：用于初始化或清除优先级状态
export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;

// 同步 hydration 优先级：服务端渲染 hydration 阶段的同步更新
export const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001;
// 同步优先级：最高优先级，用于紧急同步更新（如 flushSync）
export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010;
export const SyncLaneIndex: number = 1; // 同步车道索引

// 输入连续 hydration 优先级：hydration 阶段的连续输入事件更新
export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100;
// 输入连续优先级：拖拽、滚动等连续用户交互的更新
export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000;

// 默认 hydration 优先级：hydration 阶段的常规更新
export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000;
// 默认优先级：大多数常规更新（如 setState）
export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000;

// 同步更新组合车道：包含同步、输入连续、默认三种高优更新车道
export const SyncUpdateLanes: Lane =
  SyncLane | InputContinuousLane | DefaultLane;

// 手势优先级：手势操作相关的更新（如点击、滑动手势）
export const GestureLane: Lane = /*                     */ 0b0000000000000000000000001000000;

// 过渡 hydration 优先级：hydration 阶段的过渡更新
const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000010000000;
// 过渡优先级组合车道：包含所有过渡子车道
const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111100000000;
// 过渡子车道1-14：用于非紧急 UI 过渡（如路由跳转、数据加载）
const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000100000000;
const TransitionLane2: Lane = /*                        */ 0b0000000000000000000001000000000;
// ... 更多过渡lanes

// 重试优先级组合车道：包含所有重试子车道
const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;
// 重试子车道1-4：用于失败任务的重试更新
const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;
const RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000;
const RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000;
const RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000;

export const SomeRetryLane: Lane = RetryLane1; // 示例重试车道

// 选择性 hydration 优先级：服务端渲染中选择性 hydration 更新
export const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;

// 非空闲优先级组合：包含除空闲、离线等低优车道外的所有优先级
const NonIdleLanes: Lanes = /*                          */ 0b0000111111111111111111111111111;

// 空闲 hydration 优先级：hydration 阶段的空闲更新
export const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;
// 空闲优先级：最低优先级，浏览器空闲时执行（如预加载）
export const IdleLane: Lane = /*                        */ 0b0010000000000000000000000000000;

// 离线优先级：离线组件相关的更新
export const OffscreenLane: Lane = /*                   */ 0b0100000000000000000000000000000;
// 延迟优先级：延迟执行的低优更新
export const DeferredLane: Lane = /*                    */ 0b1000000000000000000000000000000;
```

## 2.1.2 位运算的数学特性

位运算是直接对二进制位进行操作的运算，它们在计算机底层执行效率极高,这让 Lanes 模型能够高效地处理优先级操作：

```js
/**
 * 检查集合a中是否包含b的任意一条Lane
 * 原理：按位与运算（&）结果非0 → 存在共有的二进制位（即重叠的Lane）
 */
export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane): boolean {
  return (a & b) !== NoLanes;
}

/**
 * 检查subset是否是set的子集（subset的所有Lane都包含在set中）
 * 数学性质：若(set & subset) === subset，则subset中所有为1的位在set中均为1
 */
export function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane): boolean {
  return (set & subset) === subset;
}

/**
 * 合并两个Lane集合，保留所有Lane
 * 数学性质：按位或（|）运算会将两侧任意为1的位设为1，满足交换律和结合律
 * 示例：0b101 | 0b011 = 0b111（合并Lane1、Lane3和Lane2）
 */
export function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
  return a | b;
}

/**
 * 求两个Lane集合的交集，仅保留共同的Lane
 * 数学性质：按位与（&）运算仅在两侧均为1的位才设为1，满足交换律和结合律
 * 示例：0b101 & 0b011 = 0b001（仅保留Lane1）
 */
export function intersectLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
  return a & b;
}

/**
 * 从set中移除subset包含的所有Lane
 * 数学原理：~b（按位非）会反转b的所有位，再与set进行与运算（&），即可剔除set中属于b的位
 * 示例：0b111 & ~0b010 = 0b101（移除Lane2）
 */
export function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {
  return set & ~subset;
}

/**
 * 从Lanes集合中提取优先级最高的Lane
 * 数学原理：在二进制补码中，-x = ~x + 1，因此x & -x会保留x最右侧的1（即数值最小的Lane，优先级最高）
 * 示例：0b110 & -0b110 = 0b010（提取最高优先级的Lane2）
 */
export function getHighestPriorityLane(lanes: Lanes): Lane {
  return lanes & -lanes;
}
```

## 2.2 Lane 分配与管理策略

React 的 Lane 优先级模型不仅仅是定义了一系列优先级，更重要的是它建立了一套完善的 Lane 分配与管理策略，确保了不同类型的更新能够获得恰当的优先级，并在调度过程中得到有效处理。

### 2.2.1 静态 Lane 的预定义分配

React 静态 Lane 采用**优先级分组预定义**策略，通过固定位掩码位置实现更新类型与优先级的强绑定。这些静态 Lane 根据其紧急程度和用途进行分组：

1.  **高优先级核心分组**（紧急更新专用）

    - **`SyncLane` (0b0000000000000000000000000000010)**：最高优先级，用于强制同步更新，例如 `flushSync`。
    - **`InputContinuousLane` (0b0000000000000000000000000001000)**：用于连续的用户输入事件，如 `mousemove`、`scroll`、`drag` 等，确保这些交互的流畅性。
    - **`DefaultLane` (0b0000000000000000000000000100000)**：大多数常规更新的默认优先级，例如 `setState`。
    - **`SyncUpdateLanes`**：是 `SyncLane | InputContinuousLane | DefaultLane` 的组合，代表了需要同步或接近同步处理的高优先级更新集合。

2.  **过渡与重试分组**（非紧急任务调度）

    - **`TransitionLanes` (0b0000000001111111111111100000000)**：由 14 个独立的子 Lane (`TransitionLane1` 到 `TransitionLane14`) 组成，用于非紧急的 UI 过渡，如路由跳转、数据加载后的状态更新。这些更新可以被中断和延迟，以避免阻塞用户交互。
    - **`RetryLanes`**：由 4 个独立的子 Lane (`RetryLane1` 到 `RetryLane4`) 组成，用于处理因 Suspense 导致的组件挂起后，数据加载完成时的重试更新。

3.  **低优先级分组**（后台任务专用）
    - **`IdleLane` (0b0010000000000000000000000000000)**：最低优先级，用于在浏览器空闲时执行的任务，例如预加载数据或不重要的后台计算。
    - **`OffscreenLane` (0b0100000000000000000000000000000)**：用于处理屏幕外（Offscreen）组件的更新，这些组件通常不可见，因此其更新可以被延迟。

### 2.2.2 动态 Lane 调整机制

动态 Lane 调整机制是 React Lane 模型的核心，它通过一系列函数在运行时根据上下文动态地分配和管理 Lane。

1.  核心分配函数：

- **作用**：这是 React 内部请求更新 Lane 的主要入口点，它根据当前的 `fiber` 状态和执行上下文来决定分配哪个 Lane。
- **执行流程**：
  - **Legacy 模式**：如果处于 Legacy 模式（非并发模式），则直接返回 `SyncLane`，确保同步更新。
  - **渲染阶段更新**：如果在渲染阶段 (`RenderContext`) 发生更新，React 会尝试复用当前渲染的 Lane，但这通常不被推荐，因为渲染阶段的 `setState` 可能会导致意料之外的行为。
  - **Transition 更新**：如果当前更新是一个 `Transition`（通过 `startTransition` 启动），`requestUpdateLane` 会调用 `requestTransitionLane` 来获取一个动态分配的 `TransitionLane`。
  - **普通事件更新**：对于普通事件更新，它会根据事件优先级（如 `DiscreteEventPriority`, `ContinuousEventPriority`, `DefaultEventPriority`）映射到相应的 Lane。值得注意的是，在 React 的实现中，`EventPriority` 和 `Lane` 是同一种类型（`export opaque type EventPriority = Lane;`），因此 `eventPriorityToLane` 函数实际上直接返回了传入的 `EventPriority` 值，即事件优先级本身就是对应的 Lane。

```js
// 简化版
export function requestUpdateLane(fiber: Fiber): Lane {
  const mode = fiber.mode;
  // Legacy 模式直接返回 SyncLane
  if (!disableLegacyMode && (mode & ConcurrentMode) === NoMode) {
    return (SyncLane: Lane);
  }

  // ... 处理渲染阶段更新的逻辑 ...

  const transition = requestCurrentTransition();
  if (transition !== null) {
    // 如果是 Transition 更新，请求一个 TransitionLane
    const actionScopeLane = peekEntangledActionLane();
    return actionScopeLane !== NoLane
      ? actionScopeLane
      : requestTransitionLane(transition);
  }

  // 根据事件优先级分配 Lane
  return eventPriorityToLane(resolveUpdatePriority());
}
```

关键辅助函数 ：

```javascript
// eventPriorityToLane：事件优先级与 Lane 的映射（直接返回对应优先级）
function eventPriorityToLane(updatePriority: EventPriority): Lane {
  return updatePriority;
}

// getEventPriority：根据事件类型判定事件优先级
export function getEventPriority(domEventName: DOMEventName): EventPriority {
  switch (domEventName) {
    // 离散事件（点击、输入等）：高优
    case "click": "input": "keydown": "mousedown": "touchstart": /* 其他离散事件 */:
      return DiscreteEventPriority;
    // 连续事件（滚动、拖拽等）：中优
    case "scroll": "mousemove": "touchmove": "wheel": /* 其他连续事件 */:
      return ContinuousEventPriority;
    // 消息事件：按调度优先级映射
    case "message":
      switch (getCurrentSchedulerPriorityLevel()) {
        case ImmediateSchedulerPriority: return DiscreteEventPriority;
        case UserBlockingSchedulerPriority: return ContinuousEventPriority;
        default: return DefaultEventPriority;
      }
    // 默认事件：低优
    default:
      return DefaultEventPriority;
  }
}

// resolveUpdatePriority：解析当前更新的最终优先级
export function resolveUpdatePriority(): EventPriority {
  // 优先取当前更新优先级
  const updatePriority = ReactDOMSharedInternals.currentUpdatePriority;
  if (updatePriority !== NoEventPriority) {
    return updatePriority;
  }
  // 无则取当前事件类型对应的优先级
  return window.event ? getEventPriority(window.event.type) : DefaultEventPriority;
}
```

2. 过渡车道循环分配：

- **作用**：专门用于为 `Transition` 更新动态分配一个可用的 `TransitionLane`。
- **避免饥饿逻辑**：`TransitionLanes` 包含 14 个子 Lane。`claimNextTransitionLane` 通过一个内部计数器 `nextTransitionLane` 循环地分配这些子 Lane。这种循环机制确保了即使有多个并发的 `Transition`，每个 `Transition` 都能获得一个独立的 Lane，从而避免某个 `Transition` 长期占用资源导致其他 `Transition` 饥饿。
- **源码关键逻辑**（简化版）：

```js
let nextTransitionLane: Lane = TransitionLane1; // 初始为第一个 TransitionLane

function claimNextTransitionLane(): Lane {
  const lane = nextTransitionLane;
  // 将 nextTransitionLane 左移一位，指向下一个 TransitionLane
  nextTransitionLane <<= 1;
  // 如果超出了 TransitionLanes 的范围，则循环回 TransitionLane1
  if ((nextTransitionLane & TransitionLanes) === NoLanes) {
    nextTransitionLane = TransitionLane1;
  }
  return lane;
}
```

3.  防止饥饿机制：

- **作用**：当低优先级任务等待时间过长时，React 会自动提升其优先级，以防止“饥饿”现象的发生。
- **实现原理**： - React 内部会记录每个 Lane 的过期时间（`expirationTime`）。
  - 在调度循环中，`markStarvedLanesAsExpired` 会检查当前时间是否超过了某个低优先级 Lane 的 `expirationTime`。
  - 如果超过，则将该 Lane 标记为“过期”（Expired），并将其优先级提升，使其能够被调度器优先处理。
  - 这种机制确保了即使是最低优先级的任务，在等待足够长的时间后，也能获得执行的机会，避免了被高优先级任务无限期地推迟。
- **源码关键逻辑**：

```js
export function markStarvedLanesAsExpired(
  root: FiberRoot,
  currentTime: number
): void {
  // 获取根节点上所有待处理的 Lane 集合
  const pendingLanes = root.pendingLanes;
  // 获取根节点上所有已挂起的 Lane 集合
  const suspendedLanes = root.suspendedLanes;
  // 获取根节点上所有已 pinged 的 Lane 集合（pinged 意味着可以重试）
  const pingedLanes = root.pingedLanes;
  // 获取所有 Lane 的过期时间数组
  const expirationTimes = root.expirationTimes;

  // 根据是否启用 RetryLane 过期策略，初始化需要检查的 Lane 集合
  let lanes = enableRetryLaneExpiration
    ? pendingLanes // 如果启用，则检查所有待处理的 Lane
    : pendingLanes & ~RetryLanes; // 如果不启用，则排除 RetryLanes 后再检查

  // 遍历所有需要检查的 Lane
  while (lanes > 0) {
    // 提取当前 Lane 集合中优先级最高的 Lane 的索引
    const index = pickArbitraryLaneIndex(lanes);
    // 根据索引计算出当前 Lane 的位掩码
    const lane = 1 << index;

    // 获取当前 Lane 的过期时间
    const expirationTime = expirationTimes[index];
    // 如果当前 Lane 没有设置过期时间 (NoTimestamp)
    if (expirationTime === NoTimestamp) {
      // 检查该 Lane 是否未被挂起，或者已被 pinged
      if (
        (lane & suspendedLanes) === NoLanes || // 未被挂起
        (lane & pingedLanes) !== NoLanes // 或者已被 pinged
      ) {
        // 如果满足条件，则计算并设置该 Lane 的新的过期时间
        expirationTimes[index] = computeExpirationTime(lane, currentTime);
      }
    } else if (expirationTime <= currentTime) {
      // 如果当前 Lane 的过期时间小于或等于当前时间，说明该 Lane 已过期
      // 将该 Lane 添加到根节点的 expiredLanes 集合中，表示其已饥饿并需要被优先处理
      root.expiredLanes |= lane;
    }

    // 从待检查的 Lane 集合中移除当前已处理的 Lane
    lanes &= ~lane;
  }
}
```

4.  **边缘场景处理**

- **过渡车道耗尽**：尽管 `TransitionLanes` 有 14 个子 Lane，但在极端情况下，如果所有子 Lane 都被长时间占用，React 会有一套降级策略，可能会临时提升某些低优先级 Lane 的优先级，以避免应用完全停滞。
- **优先级降级**：对于长时间未执行的低优先级任务（例如，用户切换到后台标签页后，后台的 `IdleLane` 更新），React 可能会将其优先级进一步降低，甚至暂停，以释放资源给用户当前关注的任务。

## 2.3 优先级继承与传播机制

React 通过 `childLanes` 和 `subtreeLanes` 机制实现 Lane 的自下而上优先级传播。

在协调过程中，当一个父节点完成其子树的协调后，它会根据子节点的 `childLanes` 和 `subtreeLanes` 来更新自身的 `subtreeLanes`。这样，父节点就能“感知”到其子树中存在的最高优先级任务，从而在调度时能够正确地处理。

这一机制主要通过 `bubbleProperties` 函数实现，该函数在 `completeWork` 阶段被调用，负责将子 Fiber 的 `lanes` 和 `childLanes` 聚合到父 Fiber 的 `subtreeLanes` 中。

```javascript
// 简化版
function bubbleProperties(completedWork: Fiber) {
  const didBailout =
    completedWork.alternate !== null &&
    completedWork.alternate.child === completedWork.child;

  let newChildLanes: Lanes = NoLanes;
  let subtreeFlags = NoFlags;

  if (!didBailout) {
    // 遍历当前 Fiber 的所有子节点
    let child = completedWork.child;
    while (child !== null) {
      // 将子节点的 lanes 和 childLanes 合并到 newChildLanes 中
      newChildLanes = mergeLanes(
        newChildLanes,
        mergeLanes(child.lanes, child.childLanes)
      );

      // 聚合子节点的副作用标志
      subtreeFlags |= child.subtreeFlags;
      subtreeFlags |= child.flags;

      child = child.sibling; // 移动到下一个兄弟节点
    }
  }

  // 将聚合后的 newChildLanes 赋值给 completedWork 的 childLanes
  completedWork.childLanes = newChildLanes;
  // 将聚合后的副作用标志赋值给 completedWork 的 subtreeFlags
  completedWork.subtreeFlags = subtreeFlags;
}
```

# 3. 时间切片调度

## 3.1 时间切片的原理与浏览器帧调度

## 3.2 任务中断与恢复的底层逻辑

# 4、Lane 与时间切片的协同工作机制

## 4.1 任务优先级与时间切片的关联流程

## 4.2 高优先级任务抢占与低优先级任务挂起
