# Lane 优先级模型与时间切片调度

# 1. 引言：并发渲染与优先级问题

在 React 早期版本中，组件的渲染过程是同步且不可中断的。当应用需要渲染大型组件树或处理频繁更新时，JavaScript 主线程会被长时间占用，导致浏览器无法及时响应用户输入（如点击、滚动），最终表现为页面卡顿、交互延迟 —— 这是传统同步渲染模型的核心痛点。

为解决这一问题，React 引入了并发渲染的理念，其核心目标是让渲染过程变得可中断、可恢复、可调度。而实现这一目标的两大支柱，正是 Lane 优先级模型与时间切片调度：

1. Lane 优先级模型：为不同类型的更新任务（如用户交互、数据加载、动画渲染等）赋予明确的优先级层级，让 React 能够识别 “什么任务更紧急”。
2. 时间切片调度：将原本一次性完成的渲染工作拆分为多个 “时间片段”，每次只占用浏览器一帧（约 16ms）中的部分时间执行，剩余时间交还给浏览器处理用户交互，从而避免主线程阻塞。

# 2. Lane 优先级模型

## 2.1 位掩码优先级的数学原理

React 的 Lane 优先级模型巧妙地利用了位掩码（Bitmask）这一计算机科学中的基础概念来表示和管理更新的优先级。

### 2.1.1 位掩码的基本概念

位掩码是一种使用二进制位（bit）来表示一组布尔值或状态的技术。在位掩码中，每一个独立的位都代表一个特定的标志或属性。如果某个位被设置为 1，则表示对应的标志为真；如果为 0，则表示为假。在 Lanes 模型中，每个位代表一个特定的优先级级别或更新类型：

```js
// 总车道数：React 限制 Lane 总数为 31（基于 31 位二进制设计）
export const TotalLanes = 31;

// 无优先级：用于初始化或清除优先级状态
export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;

// 同步 hydration 优先级：服务端渲染 hydration 阶段的同步更新
export const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001;
// 同步优先级：最高优先级，用于紧急同步更新（如 flushSync）
export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010;
export const SyncLaneIndex: number = 1; // 同步车道索引

// 输入连续 hydration 优先级：hydration 阶段的连续输入事件更新
export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100;
// 输入连续优先级：拖拽、滚动等连续用户交互的更新
export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000;

// 默认 hydration 优先级：hydration 阶段的常规更新
export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000;
// 默认优先级：大多数常规更新（如 setState）
export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000;

// 同步更新组合车道：包含同步、输入连续、默认三种高优更新车道
export const SyncUpdateLanes: Lane =
  SyncLane | InputContinuousLane | DefaultLane;

// 手势优先级：手势操作相关的更新（如点击、滑动手势）
export const GestureLane: Lane = /*                     */ 0b0000000000000000000000001000000;

// 过渡 hydration 优先级：hydration 阶段的过渡更新
const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000010000000;
// 过渡优先级组合车道：包含所有过渡子车道
const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111100000000;
// 过渡子车道1-14：用于非紧急 UI 过渡（如路由跳转、数据加载）
const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000100000000;
const TransitionLane2: Lane = /*                        */ 0b0000000000000000000001000000000;
// ... 更多过渡lanes

// 重试优先级组合车道：包含所有重试子车道
const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;
// 重试子车道1-4：用于失败任务的重试更新
const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;
const RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000;
const RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000;
const RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000;

export const SomeRetryLane: Lane = RetryLane1; // 示例重试车道

// 选择性 hydration 优先级：服务端渲染中选择性 hydration 更新
export const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;

// 非空闲优先级组合：包含除空闲、离线等低优车道外的所有优先级
const NonIdleLanes: Lanes = /*                          */ 0b0000111111111111111111111111111;

// 空闲 hydration 优先级：hydration 阶段的空闲更新
export const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;
// 空闲优先级：最低优先级，浏览器空闲时执行（如预加载）
export const IdleLane: Lane = /*                        */ 0b0010000000000000000000000000000;

// 离线优先级：离线组件相关的更新
export const OffscreenLane: Lane = /*                   */ 0b0100000000000000000000000000000;
// 延迟优先级：延迟执行的低优更新
export const DeferredLane: Lane = /*                    */ 0b1000000000000000000000000000000;
```

### 2.1.2 位运算的数学特性

位运算是直接对二进制位进行操作的运算，它们在计算机底层执行效率极高,这让 Lanes 模型能够高效地处理优先级操作：

```js
/**
 * 检查集合a中是否包含b的任意一条Lane
 * 原理：按位与运算（&）结果非0 → 存在共有的二进制位（即重叠的Lane）
 */
export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane): boolean {
  return (a & b) !== NoLanes;
}

/**
 * 检查subset是否是set的子集（subset的所有Lane都包含在set中）
 * 数学性质：若(set & subset) === subset，则subset中所有为1的位在set中均为1
 */
export function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane): boolean {
  return (set & subset) === subset;
}

/**
 * 合并两个Lane集合，保留所有Lane
 * 数学性质：按位或（|）运算会将两侧任意为1的位设为1，满足交换律和结合律
 * 示例：0b101 | 0b011 = 0b111（合并Lane1、Lane3和Lane2）
 */
export function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
  return a | b;
}

/**
 * 求两个Lane集合的交集，仅保留共同的Lane
 * 数学性质：按位与（&）运算仅在两侧均为1的位才设为1，满足交换律和结合律
 * 示例：0b101 & 0b011 = 0b001（仅保留Lane1）
 */
export function intersectLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
  return a & b;
}

/**
 * 从set中移除subset包含的所有Lane
 * 数学原理：~b（按位非）会反转b的所有位，再与set进行与运算（&），即可剔除set中属于b的位
 * 示例：0b111 & ~0b010 = 0b101（移除Lane2）
 */
export function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {
  return set & ~subset;
}

/**
 * 从Lanes集合中提取优先级最高的Lane
 * 数学原理：在二进制补码中，-x = ~x + 1，因此x & -x会保留x最右侧的1（即数值最小的Lane，优先级最高）
 * 示例：0b110 & -0b110 = 0b010（提取最高优先级的Lane2）
 */
export function getHighestPriorityLane(lanes: Lanes): Lane {
  return lanes & -lanes;
}
```

## 2.2 Lane 分配与管理策略

React 的 Lane 优先级模型不仅仅是定义了一系列优先级，更重要的是它建立了一套完善的 Lane 分配与管理策略，确保了不同类型的更新能够获得恰当的优先级，并在调度过程中得到有效处理。

### 2.2.1 静态 Lane 的预定义分配

React 静态 Lane 采用**优先级分组预定义**策略，通过固定位掩码位置实现更新类型与优先级的强绑定。这些静态 Lane 根据其紧急程度和用途进行分组：

1.  **高优先级核心分组**（紧急更新专用）

    - **`SyncLane` (0b0000000000000000000000000000010)**：最高优先级，用于强制同步更新，例如 `flushSync`。
    - **`InputContinuousLane` (0b0000000000000000000000000001000)**：用于连续的用户输入事件，如 `mousemove`、`scroll`、`drag` 等，确保这些交互的流畅性。
    - **`DefaultLane` (0b0000000000000000000000000100000)**：大多数常规更新的默认优先级，例如 `setState`。
    - **`SyncUpdateLanes`**：是 `SyncLane | InputContinuousLane | DefaultLane` 的组合，代表了需要同步或接近同步处理的高优先级更新集合。

2.  **过渡与重试分组**（非紧急任务调度）

    - **`TransitionLanes` (0b0000000001111111111111100000000)**：由 14 个独立的子 Lane (`TransitionLane1` 到 `TransitionLane14`) 组成，用于非紧急的 UI 过渡，如路由跳转、数据加载后的状态更新。这些更新可以被中断和延迟，以避免阻塞用户交互。
    - **`RetryLanes`**：由 4 个独立的子 Lane (`RetryLane1` 到 `RetryLane4`) 组成，用于处理因 Suspense 导致的组件挂起后，数据加载完成时的重试更新。

3.  **低优先级分组**（后台任务专用）
    - **`IdleLane` (0b0010000000000000000000000000000)**：最低优先级，用于在浏览器空闲时执行的任务，例如预加载数据或不重要的后台计算。
    - **`OffscreenLane` (0b0100000000000000000000000000000)**：用于处理屏幕外（Offscreen）组件的更新，这些组件通常不可见，因此其更新可以被延迟。

### 2.2.2 动态 Lane 调整机制

动态 Lane 调整机制是 React Lane 模型的核心，它通过一系列函数在运行时根据上下文动态地分配和管理 Lane。

1.  核心分配函数：

- **作用**：这是 React 内部请求更新 Lane 的主要入口点，它根据当前的 `fiber` 状态和执行上下文来决定分配哪个 Lane。
- **执行流程**：
  - **Legacy 模式**：如果处于 Legacy 模式（非并发模式），则直接返回 `SyncLane`，确保同步更新。
  - **渲染阶段更新**：如果在渲染阶段 (`RenderContext`) 发生更新，React 会尝试复用当前渲染的 Lane，但这通常不被推荐，因为渲染阶段的 `setState` 可能会导致意料之外的行为。
  - **Transition 更新**：如果当前更新是一个 `Transition`（通过 `startTransition` 启动），`requestUpdateLane` 会调用 `requestTransitionLane` 来获取一个动态分配的 `TransitionLane`。
  - **普通事件更新**：对于普通事件更新，它会根据事件优先级（如 `DiscreteEventPriority`, `ContinuousEventPriority`, `DefaultEventPriority`）映射到相应的 Lane。值得注意的是，在 React 的实现中，`EventPriority` 和 `Lane` 是同一种类型（`export opaque type EventPriority = Lane;`），因此 `eventPriorityToLane` 函数实际上直接返回了传入的 `EventPriority` 值，即事件优先级本身就是对应的 Lane。

```js
// 简化版
export function requestUpdateLane(fiber: Fiber): Lane {
  const mode = fiber.mode;
  // Legacy 模式直接返回 SyncLane
  if (!disableLegacyMode && (mode & ConcurrentMode) === NoMode) {
    return (SyncLane: Lane);
  }

  // ... 处理渲染阶段更新的逻辑 ...

  const transition = requestCurrentTransition();
  if (transition !== null) {
    // 如果是 Transition 更新，请求一个 TransitionLane
    const actionScopeLane = peekEntangledActionLane();
    return actionScopeLane !== NoLane
      ? actionScopeLane
      : requestTransitionLane(transition);
  }

  // 根据事件优先级分配 Lane
  return eventPriorityToLane(resolveUpdatePriority());
}
```

关键辅助函数 ：

```javascript
// eventPriorityToLane：事件优先级与 Lane 的映射（直接返回对应优先级）
function eventPriorityToLane(updatePriority: EventPriority): Lane {
  return updatePriority;
}

// getEventPriority：根据事件类型判定事件优先级
export function getEventPriority(domEventName: DOMEventName): EventPriority {
  switch (domEventName) {
    // 离散事件（点击、输入等）：高优
    case "click": "input": "keydown": "mousedown": "touchstart": /* 其他离散事件 */:
      return DiscreteEventPriority;
    // 连续事件（滚动、拖拽等）：中优
    case "scroll": "mousemove": "touchmove": "wheel": /* 其他连续事件 */:
      return ContinuousEventPriority;
    // 消息事件：按调度优先级映射
    case "message":
      switch (getCurrentSchedulerPriorityLevel()) {
        case ImmediateSchedulerPriority: return DiscreteEventPriority;
        case UserBlockingSchedulerPriority: return ContinuousEventPriority;
        default: return DefaultEventPriority;
      }
    // 默认事件：低优
    default:
      return DefaultEventPriority;
  }
}

// resolveUpdatePriority：解析当前更新的最终优先级
export function resolveUpdatePriority(): EventPriority {
  // 优先取当前更新优先级
  const updatePriority = ReactDOMSharedInternals.currentUpdatePriority;
  if (updatePriority !== NoEventPriority) {
    return updatePriority;
  }
  // 无则取当前事件类型对应的优先级
  return window.event ? getEventPriority(window.event.type) : DefaultEventPriority;
}
```

2. 过渡车道循环分配：

- **作用**：专门用于为 `Transition` 更新动态分配一个可用的 `TransitionLane`。
- **避免饥饿逻辑**：`TransitionLanes` 包含 14 个子 Lane。`claimNextTransitionLane` 通过一个内部计数器 `nextTransitionLane` 循环地分配这些子 Lane。这种循环机制确保了即使有多个并发的 `Transition`，每个 `Transition` 都能获得一个独立的 Lane，从而避免某个 `Transition` 长期占用资源导致其他 `Transition` 饥饿。
- **源码关键逻辑**（简化版）：

```js
let nextTransitionLane: Lane = TransitionLane1; // 初始为第一个 TransitionLane

function claimNextTransitionLane(): Lane {
  const lane = nextTransitionLane;
  // 将 nextTransitionLane 左移一位，指向下一个 TransitionLane
  nextTransitionLane <<= 1;
  // 如果超出了 TransitionLanes 的范围，则循环回 TransitionLane1
  if ((nextTransitionLane & TransitionLanes) === NoLanes) {
    nextTransitionLane = TransitionLane1;
  }
  return lane;
}
```

3.  防止饥饿机制：

- **作用**：当低优先级任务等待时间过长时，React 会自动提升其优先级，以防止“饥饿”现象的发生。
- **实现原理**： - React 内部会记录每个 Lane 的过期时间（`expirationTime`）。
  - 在调度循环中，`markStarvedLanesAsExpired` 会检查当前时间是否超过了某个低优先级 Lane 的 `expirationTime`。
  - 如果超过，则将该 Lane 标记为“过期”（Expired），并将其优先级提升，使其能够被调度器优先处理。
  - 这种机制确保了即使是最低优先级的任务，在等待足够长的时间后，也能获得执行的机会，避免了被高优先级任务无限期地推迟。
- **源码关键逻辑**：

```js
export function markStarvedLanesAsExpired(
  root: FiberRoot,
  currentTime: number
): void {
  // 获取根节点上所有待处理的 Lane 集合
  const pendingLanes = root.pendingLanes;
  // 获取根节点上所有已挂起的 Lane 集合
  const suspendedLanes = root.suspendedLanes;
  // 获取根节点上所有已 pinged 的 Lane 集合（pinged 意味着可以重试）
  const pingedLanes = root.pingedLanes;
  // 获取所有 Lane 的过期时间数组
  const expirationTimes = root.expirationTimes;

  // 根据是否启用 RetryLane 过期策略，初始化需要检查的 Lane 集合
  let lanes = enableRetryLaneExpiration
    ? pendingLanes // 如果启用，则检查所有待处理的 Lane
    : pendingLanes & ~RetryLanes; // 如果不启用，则排除 RetryLanes 后再检查

  // 遍历所有需要检查的 Lane
  while (lanes > 0) {
    // 提取当前 Lane 集合中优先级最高的 Lane 的索引
    const index = pickArbitraryLaneIndex(lanes);
    // 根据索引计算出当前 Lane 的位掩码
    const lane = 1 << index;

    // 获取当前 Lane 的过期时间
    const expirationTime = expirationTimes[index];
    // 如果当前 Lane 没有设置过期时间 (NoTimestamp)
    if (expirationTime === NoTimestamp) {
      // 检查该 Lane 是否未被挂起，或者已被 pinged
      if (
        (lane & suspendedLanes) === NoLanes || // 未被挂起
        (lane & pingedLanes) !== NoLanes // 或者已被 pinged
      ) {
        // 如果满足条件，则计算并设置该 Lane 的新的过期时间
        expirationTimes[index] = computeExpirationTime(lane, currentTime);
      }
    } else if (expirationTime <= currentTime) {
      // 如果当前 Lane 的过期时间小于或等于当前时间，说明该 Lane 已过期
      // 将该 Lane 添加到根节点的 expiredLanes 集合中，表示其已饥饿并需要被优先处理
      root.expiredLanes |= lane;
    }

    // 从待检查的 Lane 集合中移除当前已处理的 Lane
    lanes &= ~lane;
  }
}
```

4.  **边缘场景处理**

- **过渡车道耗尽**：尽管 `TransitionLanes` 有 14 个子 Lane，但在极端情况下，如果所有子 Lane 都被长时间占用，React 会有一套降级策略，可能会临时提升某些低优先级 Lane 的优先级，以避免应用完全停滞。
- **优先级降级**：对于长时间未执行的低优先级任务（例如，用户切换到后台标签页后，后台的 `IdleLane` 更新），React 可能会将其优先级进一步降低，甚至暂停，以释放资源给用户当前关注的任务。

## 2.3 Lanes 的合并与选择

### 2.3.1 Lanes 的合并

在 React 的世界里，每一个应用的根节点都维护着一个名为 pendingLanes 的字段。每当有一个新的更新被调度（即 requestUpdateLane 分配了一个 Lane），这个新的 Lane 就会通过**按位或（|）**操作，被合并到 root.pendingLanes 中。

React 通过 childLanes 和 subtreeLanes 机制实现 Lane 的自下而上优先级传播。在协调过程中，当一个父节点完成其子树的协调后，它会根据子节点的 childLanes 和 subtreeLanes 来更新自身的 subtreeLanes。这样，父节点就能“感知”到其子树中存在的最高优先级任务，从而在调度时能够正确地处理。

```javascript
// 简化版
function bubbleProperties(completedWork: Fiber) {
  const didBailout =
    completedWork.alternate !== null &&
    completedWork.alternate.child === completedWork.child;

  let newChildLanes: Lanes = NoLanes;
  let subtreeFlags = NoFlags;

  if (!didBailout) {
    // 遍历当前 Fiber 的所有子节点
    let child = completedWork.child;
    while (child !== null) {
      // 将子节点的 lanes 和 childLanes 合并到 newChildLanes 中
      newChildLanes = mergeLanes(
        newChildLanes,
        mergeLanes(child.lanes, child.childLanes)
      );

      // 聚合子节点的副作用标志
      subtreeFlags |= child.subtreeFlags;
      subtreeFlags |= child.flags;

      child = child.sibling; // 移动到下一个兄弟节点
    }
  }

  // 将聚合后的 newChildLanes 赋值给 completedWork 的 childLanes
  completedWork.childLanes = newChildLanes;
  // 将聚合后的副作用标志赋值给 completedWork 的 subtreeFlags
  completedWork.subtreeFlags = subtreeFlags;
}
```

### 2.3.1 Lanes 的合并

在每次渲染开始前，React 需要决定本次渲染应该处理哪些 `Lane` 的更新。`getNextLanes` 函数负责从 `Root` 节点的所有待处理 `Lane` 中选择最合适的 `Lane` 或 `Lane` 集合。

```javascript
/**
 * 决策当前渲染周期应处理的优先级最高的Lane集合
 * 核心逻辑：从根节点的待处理任务中，基于优先级分级和状态筛选，确定最优处理序列
 *
 * @param root - Fiber根节点，存储所有待处理Lane及相关状态
 * @param wipLanes - 当前正在进行中的任务Lane集合（Work In Progress）
 * @param rootHasPendingCommit - 标识是否存在等待提交到DOM的任务
 * @returns 本次渲染需要处理的Lane集合，作为renderLanes的候选值
 */
export function getNextLanes(
  root: FiberRoot,
  wipLanes: Lanes,
  rootHasPendingCommit: boolean
): Lanes {
  // 获取根节点上所有待处理的Lane（等待调度的更新任务）
  const pendingLanes = root.pendingLanes;
  // 若没有待处理任务，直接返回空Lane集合
  if (pendingLanes === NoLanes) return NoLanes;

  // 存储最终决策出的待处理Lane集合
  let nextLanes: Lanes = NoLanes;
  // 解构根节点中与Lane状态相关的字段：
  // - suspendedLanes：已被挂起的Lane（暂时无法处理）
  // - pingedLanes：被唤醒的Lane（挂起状态已解除，可重新处理）
  // - warmLanes：已预加载的Lane（提前做了部分准备工作）
  const {suspendedLanes, pingedLanes, warmLanes} = root;

  // 第一步：优先处理非Idle级别的高优先级任务
  // （非Idle包括用户交互、动画等需要及时响应的任务，优先级高于后台任务）
  const nonIdlePending = pendingLanes & NonIdleLanes;
  if (nonIdlePending) {
    // 1.1 先处理「未被挂起」的非Idle任务（可直接执行的高优任务）
    const unblockedNonIdle = nonIdlePending & ~suspendedLanes;
    if (unblockedNonIdle) {
      nextLanes = getHighestPriorityLanes(unblockedNonIdle);
    }
    // 1.2 若没有未挂起的，处理「已被唤醒」的非Idle任务（挂起后恢复的高优任务）
    else if (nonIdlePending & pingedLanes) {
      nextLanes = getHighestPriorityLanes(nonIdlePending & pingedLanes);
    }
    // 1.3 若前两者都没有，在允许预渲染且无待提交任务时，预加载未处理的非Idle任务
    // （提前准备，优化后续渲染性能）
    else if (enableSiblingPrerendering && !rootHasPendingCommit) {
      const nonIdleToPrewarm = nonIdlePending & ~warmLanes; // 排除已预加载的
      if (nonIdleToPrewarm)
        nextLanes = getHighestPriorityLanes(nonIdleToPrewarm);
    }
  }
  // 第二步：处理Idle级别的低优先级任务（如后台计算、非紧急更新）
  else {
    // 2.1 先处理「未被挂起」的Idle任务（可直接执行的低优任务）
    const unblockedIdle = pendingLanes & ~suspendedLanes;
    if (unblockedIdle) {
      nextLanes = getHighestPriorityLanes(unblockedIdle);
    }
    // 2.2 若没有未挂起的，处理「已被唤醒」的Idle任务（挂起后恢复的低优任务）
    else if (pingedLanes) {
      nextLanes = getHighestPriorityLanes(pingedLanes);
    }
    // 2.3 若前两者都没有，在允许预渲染且无待提交任务时，预加载未处理的Idle任务
    else if (enableSiblingPrerendering && !rootHasPendingCommit) {
      const idleToPrewarm = pendingLanes & ~warmLanes; // 排除已预加载的
      if (idleToPrewarm) nextLanes = getHighestPriorityLanes(idleToPrewarm);
    }
  }

  // 若未筛选出任何可处理的任务，返回空
  if (!nextLanes) return NoLanes;

  // 第三步：与当前正在处理的任务对比，避免低优任务打断高优任务
  if (
    wipLanes && // 存在正在进行的任务
    wipLanes !== nextLanes && // 新筛选的任务与当前任务不同
    !(wipLanes & suspendedLanes) // 当前任务未被挂起（仍可继续处理）
  ) {
    // 提取两者的最高优先级Lane进行比较
    const highestNextLane = getHighestPriorityLane(nextLanes);
    const highestWipLane = getHighestPriorityLane(wipLanes);

    // 规则1：若新任务优先级不高于当前任务，继续处理当前任务
    // 规则2：若新任务是默认Lane，且当前任务是过渡Lane（可中断），也继续处理当前任务
    if (
      highestNextLane >= highestWipLane ||
      (highestNextLane === DefaultLane && highestWipLane & TransitionLanes)
    ) {
      return wipLanes;
    }
  }

  // 返回最终决策的Lane集合，作为本次渲染的目标
  return nextLanes;
}
```

**工作原理：**

通过优先级分级（先非 Idle 后 Idle）、状态筛选（未挂起 → 已唤醒 → 待预加载）及冲突处理（保留更高优先级任务），最终确定当前渲染的目标 Lane 集合（renderLanes）。核心规则包括优先级最高原则、饥饿原则（低优先级任务久等后提升）及并发模式下对可中断 Lane 的倾斜。

## 2.4 实战案例：Lane 如何协调更新冲突

为了更好地理解 `Lane` 机制在协调更新冲突中的作用，我们来看两个实际案例。

### 案例一：高优先级用户输入中断低优先级后台更新

想象一个场景：用户在一个搜索框中输入文本以过滤一个列表，同时应用正在后台加载更多数据。用户输入是高优先级任务，而后台数据加载是低优先级任务。

```javascript
import React, {useState, useEffect} from "react";

function InteractiveList() {
  const [filterText, setFilterText] = useState("");
  const [data, setData] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // 模拟一个耗时的后台数据加载，这是一个低优先级任务
    const timer = setTimeout(() => {
      setData(["123", "456", "789"]);
      setIsLoading(false);
    }, 2000); // 模拟 2 秒加载时间

    return () => clearTimeout(timer);
  }, []);

  const handleFilterChange = (e) => {
    // 用户输入，这是一个高优先级任务 (DiscreteEventPriority -> SyncLane)
    setFilterText(e.target.value);
  };

  const filteredData = data.filter((item) =>
    item.toLowerCase().includes(filterText.toLowerCase())
  );

  return (
    <div>
      <h2>数字</h2>
      <input
        type="text"
        value={filterText}
        onChange={handleFilterChange}
        placeholder="输入..."
      />
      {isLoading ? (
        <p>加载中...</p>
      ) : (
        <ul>
          {filteredData.map((item) => (
            <li key={item}>{item}</li>
          ))}
        </ul>
      )}
    </div>
  );
}

export default InteractiveList;
```

**Lane 如何协调冲突：**

- **低优先级更新 (`setData`, `setIsLoading`)**: `useEffect` 中的 `setTimeout` 模拟了后台数据加载。`setData` 和 `setIsLoading` 触发的更新通常会被分配到较低优先级的 `Lane` (例如 `DefaultLane`)，因为它们不直接响应用户交互。
- **高优先级更新 (`setFilterText`)**: `handleFilterChange` 响应用户输入事件。`setFilterText` 触发的更新会被分配到高优先级的 `Lane` (例如 `SyncLane` 或 `InputContinuousLane`)。
- **冲突协调**: 如果用户在数据加载过程中（`isLoading` 为 `true`）开始输入过滤文本，React 的 `Lane` 调度机制会发挥作用。高优先级的用户输入更新会中断正在进行的低优先级数据加载更新的渲染。React 会优先处理用户输入，确保输入框的响应是即时的。被中断的数据加载更新不会丢失，它会在高优先级更新完成后，在下一个可用的时间片继续或重新开始。这保证了用户界面的流畅性和响应性。

### 案例二：使用 `startTransition` 优化耗时渲染

考虑一个需要渲染大量数据或执行复杂计算的组件，直接更新可能导致 UI 卡顿。`startTransition` 允许我们将这类非紧急更新标记为“可中断”的低优先级任务。

```javascript
import React, {useState, useTransition} from "react";

// 模拟一个计算量大、渲染耗时的组件
const ComplexChart = React.memo(({dataPoints, highlightIndex}) => {
  console.log("Rendering ComplexChart with", dataPoints.length, "data points");
  // 模拟大量计算和渲染工作
  const items = [];
  for (let i = 0; i < dataPoints.length; i++) {
    items.push(
      <div
        key={i}
        style={{
          height: dataPoints[i] / 10 + "px",
          backgroundColor: i === highlightIndex ? "red" : "blue",
          width: "2px",
          display: "inline-block",
          margin: "0 1px",
        }}
      ></div>
    );
  }
  return (
    <div
      style={{
        border: "1px solid #ccc",
        height: "100px",
        overflowX: "auto",
        whiteSpace: "nowrap",
      }}
    >
      {items}
    </div>
  );
});

function Dashboard() {
  const [chartData, setChartData] = useState(
    Array.from({length: 100}, () => Math.random() * 1000)
  );
  const [highlightedItem, setHighlightedItem] = useState(-1);
  const [isPending, startTransition] = useTransition();

  const generateNewData = () => {
    // 这是一个可能导致 UI 卡顿的更新，使用 startTransition 包裹
    startTransition(() => {
      setChartData(Array.from({length: 5000}, () => Math.random() * 1000)); // 大量数据更新
    });
  };

  const handleHighlight = (e) => {
    // 用户交互，高优先级更新
    setHighlightedItem(parseInt(e.target.value, 10));
  };

  return (
    <div>
      <h2>数据仪表盘</h2>
      <button onClick={generateNewData} disabled={isPending}>
        {isPending ? "生成中..." : "生成大量数据图表"}
      </button>
      <input
        type="number"
        min="0"
        max={chartData.length - 1}
        value={highlightedItem}
        onChange={handleHighlight}
        placeholder="高亮索引"
      />
      {isPending && <p>图表正在生成，您可以继续操作...</p>}
      <ComplexChart dataPoints={chartData} highlightIndex={highlightedItem} />
    </div>
  );
}

export default Dashboard;
```

**Lane 如何协调冲突：**

- **`ComplexChart` (耗时渲染)**: `ComplexChart` 组件被设计为渲染大量数据点，模拟一个计算密集型的 UI 任务。`React.memo` 用于避免不必要的重新渲染，但首次渲染大量数据时仍然会耗时。
- **`generateNewData` (`startTransition` 包装)**: `generateNewData` 函数通过 `startTransition` 包裹 `setChartData` 更新。这意味着 `setChartData` 触发的更新会被分配到 `TransitionLane`，这是一个低优先级且可中断的 `Lane`。
- **`handleHighlight` (高优先级)**: `handleHighlight` 响应用户输入，更新 `highlightedItem`。这是一个高优先级更新，通常会被分配到 `SyncLane` 或 `InputContinuousLane`。
- **冲突协调**: 当用户点击“生成大量数据图表”按钮时，`ComplexChart` 的渲染会在 `TransitionLane` 上进行。如果此时用户在“高亮索引”输入框中输入数字，React 会立即中断 `ComplexChart` 的渲染，优先处理用户输入，更新 `highlightedItem` 并重新渲染 `ComplexChart`（如果 `highlightIndex` 改变）。`isPending` 状态可以用来在 `TransitionLane` 任务进行时提供加载反馈，同时允许用户继续与 UI 的其他部分进行交互，而不会感到卡顿。

通过这两个案例，我们可以看到 `Lane` 机制如何有效地协调不同优先级的更新，确保用户界面的流畅性和响应性，即使在处理复杂或耗时的任务时也能提供良好的用户体验。

# 3. 时间切片调度

## 3.1 时间切片的原理与浏览器帧调度

## 3.2 任务中断与恢复的底层逻辑

# 4、Lane 与时间切片的协同工作机制

## 4.1 任务优先级与时间切片的关联流程

## 4.2 高优先级任务抢占与低优先级任务挂起
