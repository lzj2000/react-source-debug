# 一、前言

# 二、函数组件的内存布局基础

要理解 Hooks 如何工作，核心是先搞懂函数组件的内存承载结构—— 所有状态、副作用都依赖「Fiber 节点」和「Hook 链表」这两个核心载体存储。

## 2.1 Fiber 节点与 memoizedState

函数组件本身是无实例的纯函数，无法像类组件那样用 this 存储状态 —— 所有状态、Hooks 信息，都寄生在组件对应的 Fiber 节点 中。可以把 Fiber 节点理解为 “函数组件的内存容器”，其关键字段直接决定了状态的存储与读取逻辑。

### Fiber 节点的核心结构

Fiber 节点与函数组件状态相关的核心字段如下（剔除调度、树结构等非核心字段）：

```javascript
function FiberNode(tag, pendingProps, key, mode) {
  // 1. 状态存储核心：函数组件的 Hooks 链表入口
  this.memoizedState = null; // 关键！指向第一个 Hook 节点（如 useState、useEffect 节点）
  // 2. 组件接收的 props：上次渲染时使用的 props（用于依赖对比）
  this.memoizedProps = null;
  // 3. 更新队列：管理函数组件的副作用、事件等（如 useEffect 队列）
  this.updateQueue = null;
  // 4. 双缓冲关联：指向另一棵树的 Fiber 节点（当前树/工作树切换用）
  this.alternate = null;
}
```

### memoizedState：Hook 链表的入口

对于函数组件，`memoizedState` 字段具有特殊意义——它是整个 Hook 链表的入口点。与类组件不同，函数组件的 `memoizedState` 不直接存储状态对象，而是指向第一个 Hook 节点。

```javascript
// 函数组件的 memoizedState 指向 Hook 链表头部
fiber.memoizedState = firstHook; // Hook 链表的第一个节点

// 类组件的 memoizedState 直接存储状态对象
classComponentFiber.memoizedState = {count: 0, name: "React"};
```

### 渲染过程中的状态管理

函数组件每次渲染（首次 / 重渲染），都会通过 renderWithHooks 函数初始化内存结构，核心是 “重置链表入口 + 选择调度器”：

```javascript
export function renderWithHooks(
  current, // 当前 Fiber 节点（已渲染到屏幕的）
  workInProgress, // 工作 Fiber 节点（本次要渲染的）
  Component, // 函数组件本身
  props, // 组件接收的 props
  nextRenderLanes // 渲染优先级
) {
  // 1. 绑定全局变量：让 Hooks 能找到当前正在渲染的 Fiber 节点
  currentlyRenderingFiber = workInProgress;
  // 2. 重置 Hooks 链表入口：避免上次渲染的链表残留
  workInProgress.memoizedState = null;
  // 3. 选择 Hooks 调度器：首次渲染用 Mount 调度器，重渲染用 Update 调度器
  ReactSharedInternals.H =
    current === null
      ? HooksDispatcherOnMount // 首次渲染：创建新 Hook 节点
      : HooksDispatcherOnUpdate; // 重渲染：复用已有 Hook 节点
  // 4. 执行函数组件：触发 useState、useEffect 调用，构建/复用 Hooks 链表
  const children = Component(props);
  // 5. 清理全局变量，完成渲染
  finishRenderingHooks(current, workInProgress, Component);
  return children;
}
```

简单说：renderWithHooks 是 “内存初始化的开关”，决定了 Hooks 链表是 “新建” 还是 “复用”，是连接函数组件与 Fiber 节点的核心桥梁。

## 2.2 Hook 链表与更新队列的存储机制

### Hook 节点的内存结构

无论是什么类型的 Hook（useState/useEffect），都共享同一个基础结构，核心字段如下：

```javascript
type Hook = {
  memoizedState: any, // 1. 当前 Hook 的状态值（如 useState 的 count，useEffect 的依赖数组）
  baseState: any, // 2. 基础状态（用于状态合并，如多次 setState 合并）
  baseQueue: Update<any> | null, // 3. 未处理的更新队列（如 useState 的待执行 setCount）
  queue: any, // 4. 当前 Hook 的更新队列（如 useState 的更新回调队列）
  next: Hook | null, // 5. 链表指针：指向下一个 Hook 节点（关键！实现链式存储）
};
```

不同 Hook 的差异，仅体现在 memoizedState 和 queue 的具体内容（如 useEffect 的 memoizedState 存副作用函数和依赖，useState 存具体数值）。

### 链表的构建与遍历

以一个包含多个 Hook 的函数组件为例：

```javascript
function MyComponent() {
  const [count, setCount] = useState(0); // Hook1
  const [name, setName] = useState("React"); // Hook2
  useEffect(() => {
    // Hook3
    document.title = `Count: ${count}`;
  }, [count]);

  return (
    <div>
      {count} - {name}
    </div>
  );
}
```

其内存布局如下：

```
// Fiber 节点：memoizedState 指向第一个 Hook 节点
MyComponentFiber {
  memoizedState: Hook1 (useState(count)), // 链表入口
  memoizedProps: { ... }, // 组件接收的 props
  updateQueue: { ... }, // 副作用队列
  alternate: null
}

// Hook1：useState(count) 节点
Hook1 {
  memoizedState: 0, // 当前状态值：count = 0
  baseState: 0,
  queue: { ... }, // setCount 的更新队列
  next: Hook2 (useState(name)) // 指向第二个 Hook
}

// Hook2：useState(name) 节点
Hook2 {
  memoizedState: "React", // 当前状态值：name = "React"
  baseState: "React",
  queue: { ... }, // setName 的更新队列
  next: Hook3 (useEffect) // 指向第三个 Hook
}

// Hook3：useEffect 节点
Hook3 {
  memoizedState: { // 存副作用相关信息
    create: () => { document.title = `Count: ${count}`; }, // 副作用函数
    destroy: null, // 清理函数（本例无）
    deps: [0] // 依赖数组：[count]
  },
  baseState: null,
  queue: null,
  next: null // 最后一个 Hook，next 为 null
}
```

链表顺序严格遵循 Hooks 的调用顺序（Hook1→Hook2→Hook3），这也是 “不能在条件语句中写 Hooks” 的根本原因（会打乱链表顺序）；
每个 Hook 节点的 next 指针是 “链式存储” 的关键，遍历链表时通过 next 依次访问所有 Hook；
Fiber 节点仅需持有链表的 “头指针”（memoizedState），就能找到所有 Hook 节点，实现高效的状态管理。

### FunctionComponentUpdateQueue 结构

除了 Hooks 链表，函数组件的 Fiber 节点还通过 updateQueue 字段存储辅助信息，其类型为 FunctionComponentUpdateQueue，核心用于管理副作用和事件：

```javascript
// FunctionComponentUpdateQueue 定义
export type FunctionComponentUpdateQueue = {
  lastEffect: Effect | null, // 指向最后一个 Effect 节点（如 useEffect 队列）
  events: Array<EventFunctionPayload> | null, // 事件处理队列（如 useEffectEvent）
  stores: Array<StoreConsistencyCheck> | null, // 状态一致性检查
  memoCache: MemoCache | null, // 记忆化缓存（如 useMemo/useCallback 的缓存）
};
```

它相当于 Hooks 链表的 “辅助仓库”，专门存储链表之外的副作用调度信息，与 Hooks 链表配合实现完整的状态与副作用管理。

# 三、useState 的底层实现机制

## 3.1 mountState：初始化状态管理

## 3.2 updateState：状态更新流程

## 3.3 UpdateQueue 与优先级调度

# 四、useEffect 的底层实现机制

## 4.1 Effect 链表结构

## 4.2 EffectInstance 与生命周期管理

## 4.3 依赖比较与副作用调度
