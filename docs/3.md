# 一、前言

# 二、函数组件的内存布局基础

要理解 Hooks 如何工作，核心是先搞懂函数组件的内存承载结构—— 所有状态、副作用都依赖「Fiber 节点」和「Hook 链表」这两个核心载体存储。

## 2.1 Fiber 节点与 memoizedState

函数组件本身是无实例的纯函数，无法像类组件那样用 this 存储状态 —— 所有状态、Hooks 信息，都寄生在组件对应的 Fiber 节点 中。可以把 Fiber 节点理解为 “函数组件的内存容器”，其关键字段直接决定了状态的存储与读取逻辑。

### Fiber 节点的核心结构

Fiber 节点与函数组件状态相关的核心字段如下（剔除调度、树结构等非核心字段）：

```javascript
function FiberNode(tag, pendingProps, key, mode) {
  // 1. 状态存储核心：函数组件的 Hooks 链表入口
  this.memoizedState = null; // 关键！指向第一个 Hook 节点（如 useState、useEffect 节点）
  // 2. 组件接收的 props：上次渲染时使用的 props（用于依赖对比）
  this.memoizedProps = null;
  // 3. 更新队列：管理函数组件的副作用、事件等（如 useEffect 队列）
  this.updateQueue = null;
  // 4. 双缓冲关联：指向另一棵树的 Fiber 节点（当前树/工作树切换用）
  this.alternate = null;
}
```

### memoizedState：Hook 链表的入口

对于函数组件，`memoizedState` 字段具有特殊意义——它是整个 Hook 链表的入口点。与类组件不同，函数组件的 `memoizedState` 不直接存储状态对象，而是指向第一个 Hook 节点。

```javascript
// 函数组件的 memoizedState 指向 Hook 链表头部
fiber.memoizedState = firstHook; // Hook 链表的第一个节点

// 类组件的 memoizedState 直接存储状态对象
classComponentFiber.memoizedState = { count: 0, name: "React" };
```

### 渲染过程中的状态管理

函数组件每次渲染（首次 / 重渲染），都会通过 renderWithHooks 函数初始化内存结构，核心是 “重置链表入口 + 选择调度器”：

```javascript
export function renderWithHooks(
  current, // 当前 Fiber 节点（已渲染到屏幕的）
  workInProgress, // 工作 Fiber 节点（本次要渲染的）
  Component, // 函数组件本身
  props, // 组件接收的 props
  nextRenderLanes // 渲染优先级
) {
  // 1. 绑定全局变量：让 Hooks 能找到当前正在渲染的 Fiber 节点
  currentlyRenderingFiber = workInProgress;
  // 2. 重置 Hooks 链表入口：避免上次渲染的链表残留
  workInProgress.memoizedState = null;
  // 3. 选择 Hooks 调度器：首次渲染用 Mount 调度器，重渲染用 Update 调度器
  ReactSharedInternals.H =
    current === null
      ? HooksDispatcherOnMount // 首次渲染：创建新 Hook 节点
      : HooksDispatcherOnUpdate; // 重渲染：复用已有 Hook 节点
  // 4. 执行函数组件：触发 useState、useEffect 调用，构建/复用 Hooks 链表
  const children = Component(props);
  // 5. 清理全局变量，完成渲染
  finishRenderingHooks(current, workInProgress, Component);
  return children;
}
```

简单说：renderWithHooks 是 “内存初始化的开关”，决定了 Hooks 链表是 “新建” 还是 “复用”，是连接函数组件与 Fiber 节点的核心桥梁。

## 2.2 Hook 链表与更新队列的存储机制

### Hook 节点的内存结构

无论是什么类型的 Hook（useState/useEffect），都共享同一个基础结构，核心字段如下：

```javascript
type Hook = {
  memoizedState: any, // 1. 当前 Hook 的状态值（如 useState 的 count，useEffect 的依赖数组）
  baseState: any, // 2. 基础状态（用于状态合并，如多次 setState 合并）
  baseQueue: Update<any> | null, // 3. 未处理的更新队列（如 useState 的待执行 setCount）
  queue: any, // 4. 当前 Hook 的更新队列（如 useState 的更新回调队列）
  next: Hook | null, // 5. 链表指针：指向下一个 Hook 节点（关键！实现链式存储）
};
```

不同 Hook 的差异，仅体现在 memoizedState 和 queue 的具体内容（如 useEffect 的 memoizedState 存副作用函数和依赖，useState 存具体数值）。

### 链表的构建与遍历

以一个包含多个 Hook 的函数组件为例：

```javascript
function MyComponent() {
  const [count, setCount] = useState(0); // Hook1
  const [name, setName] = useState("React"); // Hook2
  useEffect(() => {
    // Hook3
    document.title = `Count: ${count}`;
  }, [count]);

  return (
    <div>
      {count} - {name}
    </div>
  );
}
```

其内存布局如下：
![image](imgs/3-1.png)

```
// Fiber 节点：memoizedState 指向第一个 Hook 节点
MyComponentFiber {
  memoizedState: Hook1 (useState(count)), // 链表入口
  memoizedProps: { ... }, // 组件接收的 props
  updateQueue: { ... }, // 副作用队列
  alternate: null
}

// Hook1：useState(count) 节点
Hook1 {
  memoizedState: 0, // 当前状态值：count = 0
  baseState: 0,
  queue: { ... }, // setCount 的更新队列
  next: Hook2 (useState(name)) // 指向第二个 Hook
}

// Hook2：useState(name) 节点
Hook2 {
  memoizedState: "React", // 当前状态值：name = "React"
  baseState: "React",
  queue: { ... }, // setName 的更新队列
  next: Hook3 (useEffect) // 指向第三个 Hook
}

// Hook3：useEffect 节点
Hook3 {
  memoizedState: { // 存副作用相关信息
    create: () => { document.title = `Count: ${count}`; }, // 副作用函数
    destroy: null, // 清理函数（本例无）
    deps: [0] // 依赖数组：[count]
  },
  baseState: null,
  queue: null,
  next: null // 最后一个 Hook，next 为 null
}
```

链表顺序严格遵循 Hooks 的调用顺序（Hook1→Hook2→Hook3），这也是 “不能在条件语句中写 Hooks” 的根本原因（会打乱链表顺序）；
每个 Hook 节点的 next 指针是 “链式存储” 的关键，遍历链表时通过 next 依次访问所有 Hook；
Fiber 节点仅需持有链表的 “头指针”（memoizedState），就能找到所有 Hook 节点，实现高效的状态管理。

### FunctionComponentUpdateQueue 结构

除了 Hooks 链表，函数组件的 Fiber 节点还通过 updateQueue 字段存储辅助信息，其类型为 FunctionComponentUpdateQueue，核心用于管理副作用和事件：

```javascript
// FunctionComponentUpdateQueue 定义
export type FunctionComponentUpdateQueue = {
  lastEffect: Effect | null, // 指向最后一个 Effect 节点（如 useEffect 队列）
  events: Array<EventFunctionPayload> | null, // 事件处理队列（如 useEffectEvent）
  stores: Array<StoreConsistencyCheck> | null, // 状态一致性检查
  memoCache: MemoCache | null, // 记忆化缓存（如 useMemo/useCallback 的缓存）
};
```

它相当于 Hooks 链表的 “辅助仓库”，专门存储链表之外的副作用调度信息，与 Hooks 链表配合实现完整的状态与副作用管理。

# 三、useState 的底层实现机制

`useState` 是 React Hooks 中最基础也最常用的 Hook 之一，它允许你在函数组件中“存储”和“更新”状态。但它背后是如何工作的呢？在 React 内部，`useState` 的行为会根据组件是首次渲染（挂载）还是后续渲染（更新）而有所不同。

简单来说，当你的函数组件第一次被渲染时，`useState` 会走一套“初始化”流程；而当组件因为状态变化需要重新渲染时，`useState` 则会走一套“更新”流程。在整个过程中，React 还会利用一个“更新队列”和“优先级调度”机制，来确保状态更新的有序性和高效性。

## 3.1 mountState：初始化状态管理

当一个函数组件首次被渲染到屏幕上时，React 会进入一个“挂载”阶段。在这个阶段，`useState` 会被一个特殊的“Hooks 分发器”（`HooksDispatcherOnMount`）拦截，并将其内部逻辑指向 `mountState` 函数。

### 3.1.1 发生时机

- **首次渲染函数组件时**：这是 `mountState` 登场的唯一时机。想象一下，你的组件就像一个新开张的商店，`mountState` 负责为它准备好所有必要的“货架”（Hook 节点）和“库存管理系统”（更新队列）。

### 3.1.2 初始值如何处理

当你调用 `useState` 时，可以传入一个初始值，这个初始值可以是具体的数据（如 `useState(0)`），也可以是一个函数（如 `useState(() => computeInitialValue())`）。

- **懒初始化（Lazy Initialization）**：

  - 如果你传入的是一个函数（例如 `useState(() => heavyInit())`），React 不会立即执行这个函数，而是在真正需要初始值的时候才去调用它。这种方式被称为“懒初始化”，当你的初始值计算成本很高时，可以避免不必要的性能开销。

  ```javascript
  function mountStateImpl(initialState) {
    const hook = mountWorkInProgressHook(); // 创建 Hook 节点
    if (typeof initialState === "function") {
      const initialStateInitializer = initialState;
      initialState = initialStateInitializer(); // 第一次调用，获取初始值
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        // 仅在 DEV 严格模式下
        setIsStrictModeForDevtools(true);
        try {
          initialStateInitializer(); // 第二次调用，检查副作用
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
    }
    // ... 后续会用这个 initialState 来设置 hook.memoizedState 和 hook.baseState
    return hook;
  }
  ```

### 3.1.3 Hook 节点与更新队列的建立

在 `mountStateImpl` 函数中，React 会为当前的 `useState` 调用创建一个内部的 **Hook 节点**（`hook` 对象），并为它配备一个 **更新队列**（`queue` 对象）。

- **Hook 节点（`hook`）**：
  - `memoizedState`：这是 Hook 节点中最重要的字段，它存储着当前组件渲染时可以读取到的状态值。你可以把它理解为组件的“当前状态快照”。
  - `baseState`：这个字段用于在处理更新队列时，作为计算新状态的“基线”。当有多个更新排队时，`baseState` 确保 React 能够从一个已知且稳定的状态开始计算，避免因为跳过某些更新而导致状态不一致。
  ```javascript
  // ... 在 mountStateImpl 中
  hook.memoizedState = hook.baseState = initialState; // 初始时两者都等于初始值
  ```
- **更新队列（`queue`）**：

  - 每个 `useState` Hook 都会有一个独立的更新队列。这个队列是一个**环形链表**结构，专门用来存储所有待处理的状态更新。
  - **`pending: null`**：指向队列中最新待处理的更新。由于是环形链表，它通常指向链表的尾部。在初始化时，还没有任何更新，所以是 `null`。
  - **`lanes: NoLanes`**：这是一个位掩码（bitmask），用于表示队列中所有更新的优先级集合。`NoLanes` 表示当前队列中没有任何更新，因此也没有优先级。
  - **`dispatch: null`**：这个字段非常关键，它将会在稍后被绑定为我们熟悉的 `setState` 函数。在初始化阶段，它暂时是 `null`。
  - **`lastRenderedReducer: basicStateReducer`**：这是一个默认的 reducer 函数，用于处理 `useState` 的状态更新逻辑。它能识别你传入 `setState` 的是值还是函数。
  - **`lastRenderedState: initialState`**：记录上一次渲染时的状态。这个字段与 `lastRenderedReducer` 一起，用于实现“急切更新”（eager update）优化，在某些情况下可以减少一次不必要的渲染。

  ```javascript
  // ... 在 mountStateImpl 中
  const queue = {
    pending: null, // 指向最新待处理更新（环形链表尾）
    lanes: NoLanes, // 队列中所有更新的优先级集合
    dispatch: null, // 后续绑定的更新触发函数（setXxx）
    lastRenderedReducer: basicStateReducer, // 状态计算函数（默认处理值/函数类型 action）
    lastRenderedState: (initialState: any), // 上一次渲染的状态（用于优化）
  };
  hook.queue = queue;
  ```

### 3.1.4 绑定 dispatch：为什么 `setState` 引用稳定

你可能注意到，无论组件重新渲染多少次，你从 `useState` 解构出来的 `setState` 函数的引用总是稳定的，它不会变。这是 React 内部一个非常巧妙的设计。

- **闭包与绑定**：
  - 在 `mountState` 函数中，React 会创建一个 `dispatch` 函数，并通过 `Function.prototype.bind` 方法，将当前的 Fiber 节点（`currentlyRenderingFiber`）和 Hook 的更新队列（`queue`）“绑定”到 `dispatchSetState` 函数上。
  - 这个绑定操作确保了 `dispatch` 函数在组件的整个生命周期中，始终能够正确地找到它所属的 Fiber 节点和更新队列，从而触发正确的状态更新。

```javascript
function mountState(initialState) {
  const hook = mountStateImpl(initialState);
  const queue = hook.queue;
  // 绑定 dispatch：与当前 Fiber、队列闭包关联，确保稳定性
  const dispatch = dispatchSetState.bind(
    null,
    currentlyRenderingFiber, // 当前正在渲染的 Fiber 节点
    queue // 当前 Hook 的更新队列
  );
  queue.dispatch = dispatch; // 将绑定后的 dispatch 存储到队列中
  return [hook.memoizedState, dispatch]; // 返回 [状态, 更新函数]
}
```

### 3.1.5 `action` 长什么样：值或函数都可以

当你调用 `setState(action)` 时，`action` 可以是两种形式：

1.  **直接的值**：例如 `setCount(10)`，此时 `action` 就是 `10`。
2.  **一个函数**：例如 `setCount(prevCount => prevCount + 1)`，此时 `action` 是一个接收上一个状态作为参数并返回新状态的函数。

这两种形式的 `action` 都是由 `basicStateReducer` 这个内部函数来处理的：

```javascript
function basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {
  return typeof action === "function" ? action(state) : action;
}
```

## 3.2 updateState：状态更新流程

当组件已经挂载完成，并且因为 `setState` 调用导致状态发生变化时，React 会进入“更新”阶段。此时，`useState` 的内部逻辑会路由到 `updateState` 函数。

### 3.2.1 发生时机

- **组件后续渲染时**：只要组件不是第一次渲染，并且因为某种原因（例如父组件重新渲染、自身状态更新等）需要重新执行函数体时，`useState` 就会调用 `updateState`。

### 3.2.2 `useState` 是 `useReducer` 的特殊形式

一个非常重要的概念是：`useState` 在底层其实是 `useReducer` 的一个简化版本。`updateState` 函数的实现清晰地展示了这一点：

```javascript
function updateState<S>(
  initialState: (() => S) | S
): [S, Dispatch<BasicStateAction<S>>] {
  // 实际上是调用了 updateReducer，并传入了 basicStateReducer 作为默认的 reducer
  return updateReducer(basicStateReducer, initialState);
}
```

这意味着 `useState` 的所有状态更新逻辑，包括如何处理更新队列、如何计算新状态、如何处理优先级等，都复用了 `useReducer` 的核心机制。`useState` 只是提供了一个更简洁的 API 封装。

### 3.2.3 `updateReducer` 的核心工作

`updateReducer` 是处理 Hook 状态更新的核心函数。它会遍历 Hook 的更新队列，并根据队列中的更新来计算出最新的状态。

- **获取 Hook 节点和队列**：

  - `updateReducer` 首先会获取当前正在处理的 Hook 节点（`hook`）以及它关联的更新队列（`queue`）。

```javascript
function updateReducerImpl<S, A>(
  hook: Hook,
  current: Hook, // 上一次渲染的 Hook 节点
  reducer: (S, A) => S
): [S, Dispatch<A>] {
  const queue = hook.queue;
  // ...
}
```

- **遍历更新队列，计算新状态**：

  - `updateReducer` 会从 `hook.baseState`（基线状态）开始，沿着更新队列（`queue.pending` 指向的环形链表）逐个处理每一个更新。
  - 对于每个更新，它会调用传入的 `reducer` 函数（对于 `useState` 来说就是 `basicStateReducer`），将当前状态和更新的 `action` 传给 `reducer`，得到新的状态。

- **急切更新优化（Eager Update Optimization）**：

  - 在某些情况下，React 会尝试进行“急切更新”优化。如果一个更新的 `action` 是一个值（而不是函数），并且这个值与当前状态不同，React 可能会在不触发完整调度的情况下，提前计算出新的状态并更新 `hook.memoizedState`。
  - 这种优化可以减少不必要的渲染，提高响应速度。

- **处理优先级（Lanes）**：
  - 在遍历更新队列时，`updateReducer` 还会考虑每个更新的优先级（`lane`）。它会确保只有那些优先级足够高的更新才会被处理。低优先级的更新可能会被跳过，留待后续的渲染周期处理。

### 3.2.4 返回值

`updateState` 最终会返回一个数组 `[state, dispatch]`，其中 `state` 是经过所有有效更新计算后的最新状态，而 `dispatch` 仍然是那个稳定的 `setState` 函数。

## 3.3 UpdateQueue 与优先级调度

# 四、useEffect 的底层实现机制

## 4.1 Effect 链表结构

## 4.2 EffectInstance 与生命周期管理

## 4.3 依赖比较与副作用调度
