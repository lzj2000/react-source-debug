# 一、导论

## 1.1 React 事件机制的目标与优势

React 事件机制的核心目标，是**在抹平浏览器差异的基础上，提供高性能、可扩展、与组件模型深度融合的事件处理能力**，具体可拆解为三大优势：

#### 优势一：跨浏览器兼容性统一

React 事件层通过 “合成事件（SyntheticEvent）” 封装原生事件，将不同浏览器的差异屏蔽在底层。例如：

- 统一事件属性：无论浏览器原生事件中是  `keyCode`（IE）还是  `key`（标准），React 都通过  `e.key`  提供一致的键盘按键信息；
- 统一方法行为：`e.preventDefault()` `e.stopPropagation()`  等方法在所有浏览器中表现完全一致，开发者无需手动判断浏览器类型。

#### 优势二：与 React 组件模型深度融合

React 事件机制并非独立存在，而是与 Fiber 架构、组件状态管理紧密联动，支持多种高级特性：

- 精准关联组件：事件触发时，React 通过  `targetFiber`  快速定位到触发事件的组件，确保监听函数与组件实例正确绑定，避免 “this 指向丢失” 等问题；
- 支持优先级调度：结合 React 的 Lane 优先级模型，事件可按优先级执行（如用户输入的  `click`  优先级高于定时器触发的事件），确保交互响应的流畅性；

#### 优势三：基于事件委托的性能优化

React 事件层采用 “事件委托” 模式，将所有事件监听统一绑定在应用的根 DOM 节点（如  `#root`），而非每个具体组件节点。其优化逻辑如下：

- 减少监听数量：无论页面有多少个按钮，只需在根节点绑定一个  `click`  监听，大幅降低内存占用；
- 自动管理生命周期：组件挂载时，React 只需在内部维护 “组件 - 监听函数” 的映射关系，无需操作 DOM 绑定；组件卸载时，直接移除映射即可，避免内存泄漏；
- 批量处理事件：事件触发时，React 会通过 Fiber 树遍历找到所有相关的监听函数，批量执行，减少浏览器的事件调度开销。

例如一个包含 1000 条数据的列表，每条数据有删除按钮，原生开发需绑定 1000 个  `click`  监听，而 React 只需 1 个根节点监听，性能优势显著。

## 1.2 核心概念速览（委托、合成、优先级）

理解 React 事件机制，需先掌握三个核心概念，它们是整个事件层的基石：

#### 概念一：事件委托

事件委托是 React 事件性能优化的核心手段，基于浏览器 “事件冒泡” 特性实现：

- 原理：将子节点的事件监听 “委托” 给父节点（最终是根节点），当子节点触发事件时，事件会向上冒泡到根节点，由根节点的监听函数统一处理；
- React 实现：根节点的原生监听函数触发后，React 会通过原生事件的  `target`  找到对应的组件 Fiber 节点，再遍历 Fiber 树收集所有相关的监听函数，按顺序执行；

例如点击一个按钮时，原生  `click`  事件会从按钮冒泡到根节点，根节点的 React 监听函数会触发，再通过 Fiber 树找到按钮组件的  `onClick`  函数并执行。

> React 并非对所有事件都采用统一的委托：对于不冒泡的原生事件（如 **`scroll`**），使用非委托绑定直接在目标元素上监听。React 会依据原生事件的冒泡特性与兼容性选择绑定方式，而非一刀切。

#### 概念二：合成事件

合成事件是 React 对原生事件的 “标准化封装”，是开发者直接操作的事件对象：

- 本质：并非替换原生事件，而是在原生事件基础上添加统一的属性和方法，同时保留原生事件引用（`e.nativeEvent`）；
- 核心特性：通过统一事件属性与方法行为实现跨浏览器兼容，以轻量设计避免冗余属性，并借助内置  `_targetInst`  等属性关联事件对应的 Fiber 节点，确保监听函数与组件实例正确绑定。

#### 概念三：事件优先级

事件优先级是 React 确保交互流畅性的关键，与整体的 Lane 优先级模型对齐，将事件分为不同优先级：

- 离散事件：最高优先级，对应用户即时交互（如  `click` `keydown`），需立即执行，避免卡顿；
- 连续事件：中优先级，对应持续触发的事件（如  `scroll` `mousemove` ），可适当延迟，避免阻塞主线程；
- 默认事件：默认优先级，对应非用户直接触发的事件（如  `load`），在正常调度下处理，可能被更高优先级（如点击、滚动）打断。
- 空闲事件：最低优先级，仅在主线程完全空闲时执行（如统计上报）。

优先级的作用的是：当多个事件同时触发时，React 会优先处理高优先级事件产生的“更新”，确保用户交互的响应速度；低优先级的“更新”则可能被延后或被中断。例如用户点击按钮的同时触发滚动，点击回调产生的更新会以更高优先级入队并更快处理；滚动产生的更新可能稍后执行。

# 二、事件系统整体架构

## 2.1 事件入口与容器/Fiber 关联

## 2.2 数据流总览（捕获 → 提取 → 分发）

# 三、根监听与事件注册

## 3.1 根级统一注册与委托策略

## 3.2 非委托与特殊场景（scroll、selectionchange）

# 四、事件优先级与更新调度

## 4.1 优先级分类与映射（离散/连续/默认/空闲）

## 4.2 优先级对更新中断与响应性的影响

# 五、合成事件与传播模型

## 5.1 合成事件创建与标准化

## 5.2 捕获/冒泡的监听聚合与执行

# 六、插件系统详解

## 6.1 插件职责与事件提取（Simple/EnterLeave/BeforeInput）

## 6.2 插件的扩展与维护
