# Commit 阶段的 3 个子阶段与副作用执行全解析

# 一、前言

Commit 阶段是 React 更新流程的最后一环，用于把 Render 阶段计算出的变更与副作用原子化地应用到宿主环境（DOM），确保界面一致性与不出现中间态。

# 二、React 全流程视角下的 Commit 阶段

## 2.1 React 渲染全流程回顾

![image](imgs/7-1.png)

1. 触发：来自事件、`setState`、`dispatch`、`startTransition`、异步回调等，进入调度。
2. 调度：为更新分配车道（`Lane`），选择下一批工作（`getNextLanes`），安排回调。
3. Render（可中断）：自顶向下构建/复用 Fiber，Diff 得出宿主层变更与副作用列表；不会触碰 DOM。
4. Commit（不可中断）：原子化应用 DOM 变更，执行 layout 类副作用与 ref，保证可见更新的一致性。
5. 绘制（Paint）：浏览器将提交的变更绘制到屏幕。
6. 被动阶段（Passive）：在一个独立宏任务中异步冲洗 `useEffect`（HookPassive）的清理与安装，避免阻塞提交与布局。

## 2.2 Commit 阶段的核心目标

1. 原子应用宿主层变更：在一次不可中断的关键段内完成所有 DOM 插入/删除/属性更新，避免“半提交”导致的视觉撕裂。
2. 正确的副作用时序：`useInsertionEffect` 在变更前、`useLayoutEffect` 清理于变更期/安装于布局期、类组件 `DidMount/DidUpdate` 与 ref 绑定于布局期。
3. 界面一致性与可预期的读写：布局读/写必须发生在稳定的 DOM 状态上，确保测量与同步操作正确。
4. 与调度器的配合：提交期间不让步、不给调度器插入中断，确保一个提交完成后再进入绘制与被动阶段。
5. 产出后续异步工作：将 `useEffect` 的清理与安装延迟到绘制后，尽量降低对交互的阻塞。

```javascript
// 提交阶段的顺序（简化伪代码）
commitBeforeMutationEffects(root, finishedWork, lanes); // 变更前处理，如焦点/过渡
commitMutationEffects(root, finishedWork, lanes); // 应用 DOM 变更
commitLayoutEffects(root, finishedWork, lanes); // ref、类组件、layout effect 安装
// 绘制发生在上述之后；随后进入被动阶段：
flushPassiveEffects(); // useEffect 的清理和安装（异步宏任务）
```

# 三、Commit 阶段源码关键函数解析

## 3.1 入口函数：commitRoot（Commit 阶段总调度器）

- 角色定位：提交阶段的总调度器；将 Render 阶段完成的变更与副作用在宿主环境原子化应用。
- 核心特征：
  - 不可中断：提交路径置位 `CommitContext`，不调用 `shouldYield`。
  - 明确分期：严格依序执行 Before Mutation → Mutation → Layout。
  - 提交后异步：被动副作用（`useEffect`）在一个后续宏任务中冲洗，避免阻塞交互。
- 关键职责（串联三子阶段并安排 Passive）：
  - 冲刷潜在残留的被动效果，确保提交干净。
  - 进入提交上下文并短期提升更新优先级到离散事件级别。
  - 在 Mutation 结束后切换当前树：`root.current = finishedWork`。
  - 调度并在绘制后冲洗被动副作用，设置合适的更新优先级。

```javascript
function commitRoot(root, finishedWork, lanes /* ... */) {
  // 先冲刷可能残留的被动效果，确保提交干净
  do {
    flushPendingEffects();
  } while (pendingEffectsStatus !== NO_PENDING_EFFECTS);

  // 设置提交阶段的性能标记与校验
  // ...

  // 安排被动效果（Passive）后续冲洗（必要时）
  if (
    (finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||
    (finishedWork.flags & PassiveMask) !== NoFlags
  ) {
    // 常规：调度一个普通优先级任务执行 flushPassiveEffects
  } else {
    root.callbackNode = null;
    root.callbackPriority = NoLane;
  }

  // Before Mutation 子阶段（提交上下文 + 提升优先级）
  if (hasBeforeMutationEffects) {
    const prev = getCurrentUpdatePriority();
    setCurrentUpdatePriority(DiscreteEventPriority); // 提交路径短期提升为离散优先级
    const prevCtx = executionContext;
    executionContext |= CommitContext; // 进入提交上下文
    try {
      commitBeforeMutationEffects(root, finishedWork, lanes); // DOM 读前置与快照
    } finally {
      executionContext = prevCtx;
      setCurrentUpdatePriority(prev);
    }
  }

  if (!startedViewTransition) {
    flushMutationEffects(); // 执行 DOM 增删改
    flushLayoutEffects(); // 执行 useLayoutEffect、更新 ref 等
  }
}
```

## 3.2 子阶段一：Before Mutation（DOM 读前置与快照）

- 目标与时机：
  - 在任何 DOM 变更之前，读取当前宿主树状态（如焦点/选择），执行 `getSnapshotBeforeUpdate` 等。
  - 这一步确保后续变更不会破坏需要的读操作。
- 实现要点：
  - 置位 `CommitContext`，并将更新优先级短期提升到 `DiscreteEventPriority`。
  - 遍历带有 `BeforeMutationMask` 的 Fiber，触发相关副作用。
- 关键代码（简化摘录与注释）：

```javascript
// 进入 Before Mutation 子阶段
const prev = getCurrentUpdatePriority();
setCurrentUpdatePriority(DiscreteEventPriority);
const prevCtx = executionContext;
executionContext |= CommitContext; // 非渲染上下文；提交不让步
try {
  commitBeforeMutationEffects(root, finishedWork, lanes); // 读取快照、焦点处理等
} finally {
  executionContext = prevCtx;
  setCurrentUpdatePriority(prev);
}
```

### 示例：一次“点击打开弹层”的完整提交与副作用时序

以下示例展示一次离散事件（`click`）触发的更新如何穿越三个子阶段，以及绘制后的被动副作用如何执行与设定优先级。

```javascript
import React, {
  useEffect,
  useLayoutEffect,
  useRef,
  useState,
  startTransition,
} from "react";

function DialogExample() {
  const [open, setOpen] = useState(false);
  const dialogRef = useRef(null);

  // Layout 阶段执行：此处可安全测量并同步读写 DOM
  useLayoutEffect(() => {
    if (open && dialogRef.current) {
      // 运行于 Layout 子阶段：DOM 已变更且稳定
      const rect = dialogRef.current.getBoundingClientRect(); // 同步测量
      // 例如根据尺寸定位弹层
      dialogRef.current.style.top = `${rect.bottom + 8}px`;
    }
    return () => {
      // 下次提交时，Layout 清理发生在 Mutation 之前（避免脏读）
      // 可在这里撤销同步副作用（如绑定的同步事件等）
    };
  }, [open]);

  // Passive 阶段执行：绘制后再执行，避免阻塞提交/布局
  useEffect(() => {
    if (!open) return;
    // 示例：给窗口添加滚动监听，滚动时关闭弹层
    const onScroll = () => {
      // 注意：此处 setState 的更新优先级由 Passive 阶段设定：
      // priority = lowerEventPriority(DefaultEventPriority, lanesToEventPriority(pendingEffectsLanes))
      // 通常为 Default；如果本次渲染包含 Idle 等更低优先级，效果更新也会更低
      setOpen(false);
    };
    window.addEventListener("scroll", onScroll);
    return () => window.removeEventListener("scroll", onScroll); // Passive 清理
  }, [open]);

  return (
    <div>
      <button
        onClick={() => {
          // 离散事件入口（click）：触发一次高优先级更新
          setOpen(true);
        }}
      >
        打开弹层
      </button>

      {open && (
        <div ref={dialogRef}>
          弹层内容（Layout 效果会在提交后立刻测量并定位）
        </div>
      )}
    </div>
  );
}
```

- 时间线解读：

  - Before Mutation：读取现有焦点/选择，准备快照与过渡信息；不触碰 DOM。
  - Mutation：插入弹层节点、属性写入、可能的宿主层重置；随后 `root.current = finishedWork`。
  - Layout：执行 `useLayoutEffect` 清理与安装、类组件 `DidMount/DidUpdate`、`ref` 绑定；支持同步测量。
  - Paint：浏览器将变更绘制到屏幕（用户现在看到弹层）。
  - Passive：宏任务中冲洗 `useEffect` 清理与安装，此处绑定滚动监听；若滚动触发 `setOpen(false)`，该更新优先级不会高于 `DefaultEventPriority`，并可能更低（比如渲染包含 Idle 车道时）。

## 3.3 子阶段二：Mutation（应用宿主变更）

- 目标与内容：
  - 应用 DOM 变更：插入/删除/属性更新；重置/清理宿主层必要状态。
  - 切换当前树：`root.current = finishedWork`（必须在变更后、布局前）。
- 实现要点：
  - 同样在 `CommitContext` 下执行，提升到离散优先级；不调用 `shouldYield`。
  - 变更完成后执行 `resetAfterCommit` 等宿主层收尾操作。
- 关键代码（简化摘录与注释）：

```javascript
const prev = getCurrentUpdatePriority();
setCurrentUpdatePriority(DiscreteEventPriority);
const prevCtx = executionContext;
executionContext |= CommitContext;
try {
  commitMutationEffects(root, finishedWork, lanes); // 实际 DOM 写操作
  // 例如：blur 后处理、事件相关收尾等
  resetAfterCommit(root.containerInfo); // 宿主层收尾
} finally {
  executionContext = prevCtx;
  setCurrentUpdatePriority(prev);
}

// 切换当前树（发生在 Mutation 之后、Layout 之前）
root.current = finishedWork;
pendingEffectsStatus = PENDING_LAYOUT_PHASE;
```

## 3.4 子阶段三：Layout（布局副作用与 ref）

- 目标与内容：
  - 安装布局副作用：`useLayoutEffect` 的清理/安装、类组件 `componentDidMount/DidUpdate`、`ref` 绑定。
  - 在稳定的 DOM 状态下进行测量与同步操作。
- 实现要点：
  - 遍历 `LayoutMask`，触发相应副作用；保持在提交上下文中同步执行。
- 关键代码（简化摘录与注释）：

```javascript
function flushLayoutEffects() {
  if (pendingEffectsStatus !== PENDING_LAYOUT_PHASE) return;
  pendingEffectsStatus = NO_PENDING_EFFECTS;

  // 提交布局副作用（同步）
  commitLayoutEffects(root, finishedWork, lanes);

  // 后续将进入被动阶段（Passive）
  pendingEffectsStatus = PENDING_SPAWNED_WORK; // 紧随其后的衍生工作（如调度 Passive）
}
```

## 3.5 被动阶段（Passive Effects）执行与优先级

- 冲洗入口与时序：
  - 提交完成后，通过 `flushPendingEffects` 进入 `flushPassiveEffects`，依次执行 `commitPassiveUnmountEffects` 与 `commitPassiveMountEffects`。
- 优先级设定：
  - 将本次渲染的 `lanes` 折算为事件优先级：`renderPriority = lanesToEventPriority(pendingEffectsLanes)`。
  - 与 `DefaultEventPriority` 比较取更低者：`priority = lowerEventPriority(DefaultEventPriority, renderPriority)`。
  - 设置到当前更新优先级：`setCurrentUpdatePriority(priority)`。
- 执行上下文与不让步：
  - 进入时置位 `CommitContext`；在被动副作用冲洗期间不咨询 `shouldYield`。
- 关键代码（简化摘录与注释）：

```javascript
function flushPassiveEffects(wasDelayedCommit?: boolean): boolean {
  if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;

  const renderPriority = lanesToEventPriority(pendingEffectsLanes);
  const priority = lowerEventPriority(DefaultEventPriority, renderPriority);
  const prevTransition = ReactSharedInternals.T;
  const previousPriority = getCurrentUpdatePriority();

  try {
    setCurrentUpdatePriority(priority); // 设置被动阶段的更新优先级
    ReactSharedInternals.T = null;
    return flushPassiveEffectsImpl(wasDelayedCommit);
  } finally {
    setCurrentUpdatePriority(previousPriority); // 还原优先级
    ReactSharedInternals.T = prevTransition;
    // 释放根级缓存池（若有）
    releaseRootPooledCache(root, remainingLanes);
  }
}

function flushPassiveEffectsImpl(/* ... */) {
  // 禁止在渲染或提交上下文中重入被动冲洗
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    throw new Error("Cannot flush passive effects while already rendering.");
  }

  // 进入提交上下文执行被动副作用（同步，不让步）
  const prevExecutionContext = executionContext;
  executionContext |= CommitContext;
  commitPassiveUnmountEffects(root.current);
  commitPassiveMountEffects(root, root.current, lanes, transitions /* ... */);
  // ...
}
```

# 四、常见陷阱与最佳实践

- 在 useEffect 中触发更新的优先级与循环风险（无限更新防护）
- 在布局/被动阶段触发 setState 的影响与建议
