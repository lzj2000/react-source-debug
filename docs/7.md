# Commit 阶段的 3 个子阶段与副作用执行全解析

# 一、前言

Commit 阶段是 React 更新流程的最后一环，用于把 Render 阶段计算出的变更与副作用原子化地应用到宿主环境（DOM），确保界面一致性与不出现中间态。

# 二、React 全流程视角下的 Commit 阶段

## 2.1 React 渲染全流程回顾

![image](imgs/7-1.png)

1. 触发：来自事件、`setState`、`dispatch`、`startTransition`、异步回调等，进入调度。
2. 调度：为更新分配车道（`Lane`），选择下一批工作（`getNextLanes`），安排回调。
3. Render（可中断）：自顶向下构建/复用 Fiber，Diff 得出宿主层变更与副作用列表；不会触碰 DOM。
4. Commit（不可中断）：原子化应用 DOM 变更，执行 layout 类副作用与 ref，保证可见更新的一致性。
5. 绘制（Paint）：浏览器将提交的变更绘制到屏幕。
6. 被动阶段（Passive）：在一个独立宏任务中异步冲洗 `useEffect`（HookPassive）的清理与安装，避免阻塞提交与布局。

## 2.2 Commit 阶段的核心目标

1. 原子应用宿主层变更：在一次不可中断的关键段内完成所有 DOM 插入/删除/属性更新，避免“半提交”导致的视觉撕裂。
2. 正确的副作用时序：`useInsertionEffect` 在变更前、`useLayoutEffect` 清理于变更期/安装于布局期、类组件 `DidMount/DidUpdate` 与 ref 绑定于布局期。
3. 界面一致性与可预期的读写：布局读/写必须发生在稳定的 DOM 状态上，确保测量与同步操作正确。
4. 与调度器的配合：提交期间不让步、不给调度器插入中断，确保一个提交完成后再进入绘制与被动阶段。
5. 产出后续异步工作：将 `useEffect` 的清理与安装延迟到绘制后，尽量降低对交互的阻塞。

```javascript
// 提交阶段的顺序（简化伪代码）
commitBeforeMutationEffects(root, finishedWork, lanes); // 变更前处理，如焦点/过渡
commitMutationEffects(root, finishedWork, lanes); // 应用 DOM 变更
commitLayoutEffects(root, finishedWork, lanes); // ref、类组件、layout effect 安装
// 绘制发生在上述之后；随后进入被动阶段：
flushPassiveEffects(); // useEffect 的清理和安装（异步宏任务）
```

# 三、Commit 阶段源码关键函数解析

## 3.1 入口函数：commitRoot

### 3.1.1 角色定位：

提交阶段的总调度器；将 Render 阶段完成的变更与副作用在宿主环境原子化应用。

### 3.1.2 核心特征：

1. 不可中断：提交路径置位 `CommitContext`，不调用 `shouldYield`。
2. 明确分期：严格依序执行 Before Mutation → Mutation → Layout。
3. 提交后异步：被动副作用（`useEffect`）在一个后续宏任务中冲洗，避免阻塞交互。
4. 关键职责（串联三子阶段并安排 Passive）：

- 冲刷潜在残留的被动效果，确保提交干净。
- 进入提交上下文并短期提升更新优先级到离散事件级别。
- 在 Mutation 结束后切换当前树：`root.current = finishedWork`。
- 调度并在绘制后冲洗被动副作用，设置合适的更新优先级。

### 3.1.3 核心实现逻辑

```javascript
function commitRoot(root, finishedWork, lanes /* ... */) {
  // 先冲刷可能残留的被动效果，确保提交干净
  do {
    flushPendingEffects();
  } while (pendingEffectsStatus !== NO_PENDING_EFFECTS);

  // 设置提交阶段的性能标记与校验
  // ...

  // 安排被动效果（Passive）后续冲洗（必要时）
  if (
    (finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||
    (finishedWork.flags & PassiveMask) !== NoFlags
  ) {
    // 常规：调度一个普通优先级任务执行 flushPassiveEffects
  } else {
    root.callbackNode = null;
    root.callbackPriority = NoLane;
  }

  // Before Mutation 子阶段（提交上下文 + 提升优先级）
  if (hasBeforeMutationEffects) {
    const prev = getCurrentUpdatePriority();
    setCurrentUpdatePriority(DiscreteEventPriority); // 提交路径短期提升为离散优先级
    const prevCtx = executionContext;
    executionContext |= CommitContext; // 进入提交上下文
    try {
      commitBeforeMutationEffects(root, finishedWork, lanes); // DOM 读前置与快照
    } finally {
      executionContext = prevCtx;
      setCurrentUpdatePriority(prev);
    }
  }

  if (!startedViewTransition) {
    flushMutationEffects(); // 执行 DOM 增删改
    flushLayoutEffects(); // 执行 useLayoutEffect、更新 ref 等
    flushSpawnedWork(); // 提交后异步执行 flushPassiveEffects
  }
}
```

### 3.1.4 示例：一次“点击打开弹层”的完整提交与副作用时序

以下示例展示一次离散事件（`click`）触发的更新如何穿越三个子阶段，以及绘制后的被动副作用如何执行与设定优先级。

```javascript
function DialogExample() {
  const [open, setOpen] = useState(false);
  const dialogRef = useRef(null);

  // Layout 阶段执行：此处可安全测量并同步读写 DOM
  useLayoutEffect(() => {
    if (open && dialogRef.current) {
      // 运行于 Layout 子阶段：DOM 已变更且稳定
      const rect = dialogRef.current.getBoundingClientRect(); // 同步测量
      // 例如根据尺寸定位弹层
      dialogRef.current.style.top = `${rect.bottom + 8}px`;
    }
    return () => {
      // 下次提交时，Layout 清理发生在 Mutation 之前（避免脏读）
      // 可在这里撤销同步副作用（如绑定的同步事件等）
    };
  }, [open]);

  // Passive 阶段执行：绘制后再执行，避免阻塞提交/布局
  useEffect(() => {
    if (!open) return;
    // 示例：给窗口添加滚动监听，滚动时关闭弹层
    const onScroll = () => {
      // 注意：此处 setState 的更新优先级由 Passive 阶段设定：
      // priority = lowerEventPriority(DefaultEventPriority, lanesToEventPriority(pendingEffectsLanes))
      // 通常为 Default；如果本次渲染包含 Idle 等更低优先级，效果更新也会更低
      setOpen(false);
    };
    window.addEventListener("scroll", onScroll);
    return () => window.removeEventListener("scroll", onScroll); // Passive 清理
  }, [open]);

  return (
    <div>
      <button
        onClick={() => {
          setOpen(true); // 离散事件入口（click）：触发一次高优先级更新
        }}
      >
        打开弹层
      </button>

      {open && (
        <div ref={dialogRef}>
          弹层内容（Layout 效果会在提交后立刻测量并定位）
        </div>
      )}
    </div>
  );
}
```

- 时间线解读：

  - Before Mutation：读取现有焦点/选择，准备快照与过渡信息；不触碰 DOM。
  - Mutation：插入弹层节点、属性写入、可能的宿主层重置；随后 `root.current = finishedWork`。
  - Layout：执行 `useLayoutEffect` 清理与安装、类组件 `DidMount/DidUpdate`、`ref` 绑定；支持同步测量。
  - Paint：浏览器将变更绘制到屏幕（用户现在看到弹层）。
  - Passive：宏任务中冲洗 `useEffect` 清理与安装，此处绑定滚动监听；若滚动触发 `setOpen(false)`，该更新优先级不会高于 `DefaultEventPriority`，并可能更低（比如渲染包含 Idle 车道时）。

## 3.2 子阶段一：Before Mutation

简单说，这个阶段的核心是：在 DOM 发生任何增删改之前，先完成 “读状态” 和 “做准备” 的工作—— 比如记录 DOM 快照、处理焦点，避免后续 DOM 变更破坏这些需要的信息，确保数据和交互的一致性。

### 3.2.1 核心目标与执行时机

1. 核心目标：DOM 变更前，安全读取当前页面状态（如滚动位置、焦点元素、选择的文本），执行前置准备（如快照、焦点处理）。
2. 关键时机：在 Mutation 阶段（实际改 DOM）之前，且整个过程同步执行、不可中断。
3. 为什么要单独分这个阶段：如果先改 DOM 再读状态，拿到的就是变更后的数据，可能导致逻辑错误（比如想记录列表滚动位置，结果 DOM 先更新了，滚动位置变了）。

### 3.2.2 核心实现逻辑

1. 为了确保本阶段的操作不被打断（比如低优先级任务插入），会先临时切换上下文和优先级

```javascript
// 保存原来的优先级和执行上下文
const prevPriority = getCurrentUpdatePriority();
const prevCtx = executionContext;

// 提升优先级到最高（DiscreteEventPriority）：比如用户输入、点击这类紧急任务的优先级
setCurrentUpdatePriority(DiscreteEventPriority);
// 标记当前处于“提交阶段上下文”（CommitContext）：告诉 React 现在是提交阶段，不能让步
executionContext |= CommitContext;

try {
  // 核心：执行 Before Mutation 阶段的所有逻辑
  commitBeforeMutationEffects(root, finishedWork, lanes);
} finally {
  // 执行完后，恢复原来的环境（不影响后续流程）
  executionContext = prevCtx;
  setCurrentUpdatePriority(prevPriority);
}
```

2. React 不会遍历所有 Fiber 节点，而是通过 “掩码（Mask）” 快速筛选出需要处理的节点。

```javascript
/**
 * Before Mutation 阶段的副作用掩码（Mask）
 * 作用：筛选出 Before Mutation 阶段需要处理的 Fiber 节点（仅带这些标记的节点会执行该阶段逻辑）
 * 掩码通过“按位或（|）”组合，根据不同特性开关动态调整包含的副作用类型
 */
export const BeforeMutationMask =
  Snapshot | // 快照相关副作用（对应 Class 组件 getSnapshotBeforeUpdate 生命周期）
  (enableCreateEventHandleAPI // 启用 CreateEventHandle API 时（处理焦点/失焦相关逻辑）
    ? Update | ChildDeletion | Visibility // 额外包含：更新（Update）、子节点删除（ChildDeletion）、可见性变化（Visibility）
    : enableUseEffectEventHook // 未启用 CreateEventHandle，但启用 useEffectEvent Hook 时
    ? Update // 仅包含：更新（Update）（用于更新 useEffectEvent 的事件回调实现）
    : 0); // 未启用任何相关特性时，仅保留 Snapshot 标记

/**
 * 视图过渡（View Transition）场景下的扩展副作用掩码
 * 作用：在开启 View Transition 时使用，覆盖 Before Mutation 和 Mutation 阶段的过渡相关逻辑
 */
export const BeforeAndAfterMutationTransitionMask =
  Snapshot | Update | Placement | ChildDeletion | Visibility | ContentReset;
```

3. 优先处理 “待删除节点”（避免交互异常），比如某个输入框正在被聚焦，却要被删除了，这时候会先触发失焦回调，避免删除后 DOM 不存在了，却还触发焦点相关事件，导致报错。

```javascript
function commitBeforeMutationEffects_begin(isViewTransitionEligible) {
  const subtreeMask = isViewTransitionEligible
    ? BeforeAndAfterMutationTransitionMask
    : BeforeMutationMask;
  while (nextEffect !== null) {
    const fiber = nextEffect;
    if (enableCreateEventHandleAPI || isViewTransitionEligible) {
      const deletions = fiber.deletions;
      if (deletions !== null) {
        for (let i = 0; i < deletions.length; i++) {
          commitBeforeMutationEffectsDeletion(
            deletions[i],
            isViewTransitionEligible
          );
        }
      }
    }
    // ...
    nextEffect = fiber.return;
  }
}
function commitBeforeMutationEffectsDeletion(
  deletion,
  isViewTransitionEligible
) {
  if (enableCreateEventHandleAPI) {
    // 检查：要删除的节点里是否包含当前聚焦的元素
    if (doesFiberContain(deletion, ((focusedInstanceHandle: any): Fiber))) {
      shouldFireAfterActiveInstanceBlur = true;
      // 执行失焦前的预处理（如触发 blur 回调）
      beforeActiveInstanceBlur(deletion);
    }
  }
}
```

4. Class 组件当 `flags & Snapshot` 命中时，调用 `commitClassSnapshot(current, finishedWork)`，以便执行`getSnapshotBeforeUpdate`。

```javascript
// react-reconciler/src/ReactFiberCommitWork.js
case ClassComponent: {
  // 有 Snapshot 标记才处理
  if ((flags & Snapshot) !== NoFlags) {
    if (current !== null) {
       // 调用 getSnapshotBeforeUpdate 并保存快照
      commitClassSnapshot(finishedWork, current);
    }
  }
  break;
}
```

5. Function 组件当启用 `enableUseEffectEventHook` 且存在 `Update` 标记时，会在该阶段更新事件实现的引用，以保障提交前事件行为一致.

```javascript
case FunctionComponent: {
  if (enableUseEffectEventHook) {
    if ((flags & Update) !== NoFlags) {
      const updateQueue = finishedWork.updateQueue;
      const eventPayloads = updateQueue !== null ? updateQueue.events : null;
      if (eventPayloads !== null) {
        for (let ii = 0; ii < eventPayloads.length; ii++) {
          const {ref, nextImpl} = eventPayloads[ii];
          ref.impl = nextImpl;// 更新为最新的事件回调
        }
      }
    }
  }
  break;
}
```

6. HostRoot 当 `flags & Snapshot` 命中且宿主支持 Mutation 时，可能执行容器清理（如 SSR/水合相关的容器内容重置）：

```javascript
case HostRoot: {
  if ((flags & Snapshot) !== NoFlags) {
    if (supportsMutation) {
      const root = finishedWork.stateNode;
      clearContainer(root.containerInfo);
    }
  }
  break;
}
```

## 3.3 子阶段二：Mutation

Mutation 阶段是 React 真正 “动手修改 DOM” 的阶段，核心任务是将 Render 阶段计算出的 DOM 变更（插入、删除、更新）应用到真实 DOM 上，同时完成旧 Ref 解绑、宿主状态清理等关键操作。这一阶段的操作直接影响用户可见的界面，且全程同步执行、不可中断。

### 3.3.1 核心目标与执行时机

1. 核心目标：执行真实 DOM 操作（插入新节点、删除旧节点、更新属性 / 文本），并完成与 DOM 变更相关的前置清理（如旧 Ref 解绑）。
2. 关键时机：在 Before Mutation 阶段（读状态）之后，Layout 阶段（读新 DOM 状态）之前，是 “写 DOM” 的唯一阶段。
3. 为什么重要：这是虚拟 DOM 映射到真实 DOM 的 “最后一步”，所有 Render 阶段的计算结果在此落地，直接决定用户看到的界面。

### 3.3.2 核心实现逻辑

1. 和 Before Mutation 阶段类似，Mutation 阶段也需要确保操作不被打断，因此会先切换到高优先级环境，会调用`commitMutationEffectsOnFiber` 来递归处理 `finishedWork` 树。

```javascript
const prev = getCurrentUpdatePriority();
setCurrentUpdatePriority(DiscreteEventPriority);
const prevCtx = executionContext;
executionContext |= CommitContext;
try {
  commitMutationEffects(root, finishedWork, lanes); // 核心：执行所有 DOM 变更操作
  resetAfterCommit(root.containerInfo); // 宿主层收尾
} finally {
  executionContext = prevCtx;
  setCurrentUpdatePriority(prev);
}

// 关键：DOM 变更完成后，切换当前 Fiber 树（旧树 → 新树）
root.current = finishedWork;
// 标记进入下一阶段（Layout 阶段）
pendingEffectsStatus = PENDING_LAYOUT_PHASE;
```

2. `commitMutationEffectsOnFiber` 是实际执行副作用的核心。它会根据 `fiber.flags` 的不同，执行相应的操作。其基本流程是 “自上而下” 递归，但处理副作用的顺序有所不同。
   首先处理 `deletions`，在遍历子节点之前，优先处理当前 Fiber 节点上标记为 `ChildDeletion` 的所有待删除子节点。这确保了在执行其他变更前，旧的 DOM 节点已被移除；然后递归子节点：如果子树中存在 `MutationMask` 标记的变更，则继续向下遍历，对每个子节点调用 `commitMutationEffectsOnFiber`；在递归回到当前 Fiber 后，处理自身的副作用。例如，对于 `HostComponent`，会根据 `flags` 执行 `commitHostUpdate`（更新属性）或 `commitHostPlacement`（插入 DOM 树）。对于函数组件，会在这里触发 `useInsertionEffect` 的销毁和创建回调。

```javascript
function commitMutationEffectsOnFiber(
  finishedWork: Fiber,
  root: FiberRoot,
  lanes: Lanes
) {
  const flags = finishedWork.flags;

  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent: {
      // 递归处理子节点的 Mutation Effects
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      // 处理当前节点的 Placement (插入)
      commitReconciliationEffects(finishedWork);

      // 3. 如果有 Update 标记 (通常由 Hook 副作用引起)
      if (flags & Update) {
        // 卸载之前的插入副作用钩子 (useInsertionEffect)
        commitHookEffectListUnmount(
          HookInsertion | HookHasEffect,
          finishedWork,
          finishedWork.return
        );
        // 挂载新的插入副作用钩子 (useInsertionEffect)
        commitHookEffectListMount(HookInsertion | HookHasEffect, finishedWork);
        // 注意：常规的 useEffect 和 useLayoutEffect 的 unmount/mount 在此阶段不执行，
        // useLayoutEffect 在 Layout Effects 阶段，useEffect 在 Passive Effects 阶段。
        // 此处的 HookInsertion 指的是 useInsertionEffect 。
      }
      break;
    }
    case ClassComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      if (flags & Ref) {
        // 解绑旧的 ref
        const current = finishedWork.alternate;
        if (current !== null) {
          safelyDetachRef(current, current.return);
        }
      }
      break;
    }
    // DOM 元素
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      if (flags & Ref) {
        const current = finishedWork.alternate;
        if (current !== null) {
          safelyDetachRef(current, current.return);
        }
      }

      if (flags & Update) {
        const instance = finishedWork.stateNode;
        if (instance != null) {
          // 应用 DOM 属性更新
          const newProps = finishedWork.memoizedProps;
          const oldProps = current !== null ? current.memoizedProps : newProps;
          const type = finishedWork.type;
          const updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload) {
            // 调用 commitHostUpdate 执行 DOM 更新
            commitHostUpdate(
              instance,
              updatePayload,
              type,
              oldProps,
              newProps,
              finishedWork
            );
          }
        }
      }
      break;
    }
    // ... 其他类型的 Fiber
  }
}

function recursivelyTraverseMutationEffects(root, parentFiber, lanes) {
  // 优先处理删除
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i < deletions.length; i++) {
      const childToDelete = deletions[i];
      commitDeletionEffects(root, parentFiber, childToDelete);
    }
  }

  // 递归处理子节点
  if (parentFiber.subtreeFlags & MutationMask) {
    let child = parentFiber.child;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root, lanes);
      child = child.sibling;
    }
  }
}
```

## 3.4 子阶段三：Layout（布局副作用与 ref）

- 目标与内容：
  - 安装布局副作用：`useLayoutEffect` 的清理/安装、类组件 `componentDidMount/DidUpdate`、`ref` 绑定。
  - 在稳定的 DOM 状态下进行测量与同步操作。
- 实现要点：
  - 遍历 `LayoutMask`，触发相应副作用；保持在提交上下文中同步执行。
- 关键代码（简化摘录与注释）：

```javascript
function flushLayoutEffects() {
  if (pendingEffectsStatus !== PENDING_LAYOUT_PHASE) return;
  pendingEffectsStatus = NO_PENDING_EFFECTS;

  // 提交布局副作用（同步）
  commitLayoutEffects(root, finishedWork, lanes);

  // 后续将进入被动阶段（Passive）
  pendingEffectsStatus = PENDING_SPAWNED_WORK; // 紧随其后的衍生工作（如调度 Passive）
}
```

## 3.5 被动阶段（Passive Effects）执行与优先级

- 冲洗入口与时序：
  - 提交完成后，通过 `flushPendingEffects` 进入 `flushPassiveEffects`，依次执行 `commitPassiveUnmountEffects` 与 `commitPassiveMountEffects`。
- 优先级设定：
  - 将本次渲染的 `lanes` 折算为事件优先级：`renderPriority = lanesToEventPriority(pendingEffectsLanes)`。
  - 与 `DefaultEventPriority` 比较取更低者：`priority = lowerEventPriority(DefaultEventPriority, renderPriority)`。
  - 设置到当前更新优先级：`setCurrentUpdatePriority(priority)`。
- 执行上下文与不让步：
  - 进入时置位 `CommitContext`；在被动副作用冲洗期间不咨询 `shouldYield`。
- 关键代码（简化摘录与注释）：

```javascript
function flushPassiveEffects(wasDelayedCommit?: boolean): boolean {
  if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;

  const renderPriority = lanesToEventPriority(pendingEffectsLanes);
  const priority = lowerEventPriority(DefaultEventPriority, renderPriority);
  const prevTransition = ReactSharedInternals.T;
  const previousPriority = getCurrentUpdatePriority();

  try {
    setCurrentUpdatePriority(priority); // 设置被动阶段的更新优先级
    ReactSharedInternals.T = null;
    return flushPassiveEffectsImpl(wasDelayedCommit);
  } finally {
    setCurrentUpdatePriority(previousPriority); // 还原优先级
    ReactSharedInternals.T = prevTransition;
    // 释放根级缓存池（若有）
    releaseRootPooledCache(root, remainingLanes);
  }
}

function flushPassiveEffectsImpl(/* ... */) {
  // 禁止在渲染或提交上下文中重入被动冲洗
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    throw new Error("Cannot flush passive effects while already rendering.");
  }

  // 进入提交上下文执行被动副作用（同步，不让步）
  const prevExecutionContext = executionContext;
  executionContext |= CommitContext;
  commitPassiveUnmountEffects(root.current);
  commitPassiveMountEffects(root, root.current, lanes, transitions /* ... */);
  // ...
}
```

# 四、常见陷阱与最佳实践

- 在 useEffect 中触发更新的优先级与循环风险（无限更新防护）
- 在布局/被动阶段触发 setState 的影响与建议
